{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"jsonata-core + jsonatapy","text":"<p>High-performance JSONata implementation in Rust, with Python bindings.</p>"},{"location":"#two-packages-one-implementation","title":"Two packages, one implementation","text":"jsonata-core jsonatapy Language Rust Python Published on crates.io PyPI Install <code>cargo add jsonata-core</code> <code>pip install jsonatapy</code> Use when You're writing Rust You're writing Python <p><code>jsonatapy</code> is a thin PyO3 wrapper around <code>jsonata-core</code>. Both live in the same repository.</p>"},{"location":"#python-quick-start","title":"Python quick start","text":"<pre><code>pip install jsonatapy\n</code></pre> <pre><code>import jsonatapy\n\n# One-off evaluation\nresult = jsonatapy.evaluate('\"Hello, \" &amp; name', {\"name\": \"World\"})\nprint(result)  # \"Hello, World\"\n\n# Compile once, evaluate many times\nexpr = jsonatapy.compile(\"orders[price &gt; 100].product\")\nresult = expr.evaluate({\"orders\": [{\"product\": \"Laptop\", \"price\": 1200}]})\n\n# Pre-convert data for maximum throughput (6\u201315x faster for repeated queries)\ndata = jsonatapy.JsonataData(large_dataset)\nresult = expr.evaluate_with_data(data)\n</code></pre>"},{"location":"#rust-quick-start","title":"Rust quick start","text":"<pre><code>use jsonata_core::evaluator::Evaluator;\nuse jsonata_core::parser;\nuse jsonata_core::value::JValue;\n\nlet ast = parser::parse(\"orders[price &gt; 100].product\")?;\nlet data = JValue::from_json_str(r#\"{\"orders\":[{\"product\":\"Laptop\",\"price\":1200}]}\"#)?;\nlet result = Evaluator::new().evaluate(&amp;ast, &amp;data)?;\n</code></pre>"},{"location":"#performance-highlights","title":"Performance highlights","text":"<ul> <li>1258/1258 JSONata reference tests passing</li> <li>7\u201318x faster than the JavaScript reference implementation for pure expression workloads</li> <li>~40x faster than jsonata-rs (the next pure-Rust JSONata implementation)</li> <li>50\u2013150x faster than jsonata-python across all categories</li> </ul> <p>See Performance for full benchmark results.</p>"},{"location":"#what-is-jsonata","title":"What is JSONata?","text":"<p>JSONata is a query and transformation language for JSON data:</p> <ul> <li>Query \u2014 <code>person.name</code></li> <li>Filter \u2014 <code>products[price &gt; 50]</code></li> <li>Transform \u2014 <code>items.{\"name\": title, \"cost\": price}</code></li> <li>Aggregate \u2014 <code>$sum(orders.total)</code></li> <li>Conditionals \u2014 <code>price &gt; 100 ? \"expensive\" : \"affordable\"</code></li> </ul> <p>See the official JSONata docs for the full language reference.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete Python API for jsonatapy.</p>"},{"location":"api/#quick-reference","title":"Quick Reference","text":"<pre><code>import jsonatapy\n\n# One-off evaluation\nresult = jsonatapy.evaluate(expression, data, bindings=None)\n\n# Compile and reuse\nexpr = jsonatapy.compile(expression)\nresult = expr.evaluate(data, bindings=None)\n</code></pre>"},{"location":"api/#functions","title":"Functions","text":""},{"location":"api/#evaluateexpression-data-bindingsnone","title":"<code>evaluate(expression, data, bindings=None)</code>","text":"<p>Compile and evaluate a JSONata expression in one step.</p> <p>Parameters: - <code>expression</code> (str): JSONata query/transformation expression - <code>data</code> (Any): Data to query (typically dict or list) - <code>bindings</code> (Optional[Dict[str, Any]]): Optional variable bindings</p> <p>Returns: <code>Any</code> - Result of evaluating the expression</p> <p>Raises: <code>ValueError</code> - If parsing or evaluation fails</p> <p>Example: <pre><code>data = {\"name\": \"Alice\", \"age\": 30}\nresult = jsonatapy.evaluate(\"name\", data)\n# \"Alice\"\n\n# With bindings\nresult = jsonatapy.evaluate(\n    \"name &amp; suffix\",\n    {\"name\": \"Hello\"},\n    {\"suffix\": \"!\"}\n)\n# \"Hello!\"\n</code></pre></p> <p>Note: For repeated evaluations with the same expression, use <code>compile()</code> for better performance.</p>"},{"location":"api/#compileexpression","title":"<code>compile(expression)</code>","text":"<p>Compile a JSONata expression for repeated evaluation.</p> <p>Parameters: - <code>expression</code> (str): JSONata query/transformation expression</p> <p>Returns: <code>JsonataExpression</code> - Compiled expression object</p> <p>Raises: <code>ValueError</code> - If expression cannot be parsed</p> <p>Example: <pre><code>expr = jsonatapy.compile(\"orders[price &gt; 100].product\")\n\ndata1 = {\"orders\": [{\"product\": \"A\", \"price\": 150}]}\nresult1 = expr.evaluate(data1)  # [\"A\"]\n\ndata2 = {\"orders\": [{\"product\": \"B\", \"price\": 50}]}\nresult2 = expr.evaluate(data2)  # []\n</code></pre></p>"},{"location":"api/#jsonataexpression-class","title":"JsonataExpression Class","text":"<p>Compiled JSONata expression that can be evaluated multiple times.</p>"},{"location":"api/#evaluatedata-bindingsnone","title":"<code>evaluate(data, bindings=None)</code>","text":"<p>Evaluate the compiled expression against data.</p> <p>Parameters: - <code>data</code> (Any): Data to query (typically dict or list) - <code>bindings</code> (Optional[Dict[str, Any]]): Optional variable bindings</p> <p>Returns: <code>Any</code> - Result of evaluation</p> <p>Raises: <code>ValueError</code> - If evaluation fails</p> <p>Example: <pre><code>expr = jsonatapy.compile(\"$uppercase(name)\")\n\nexpr.evaluate({\"name\": \"alice\"})  # \"ALICE\"\nexpr.evaluate({\"name\": \"bob\"})    # \"BOB\"\n</code></pre></p> <p>Type Conversions:</p> <p>Python to JSONata: - <code>None</code> \u2192 null - <code>bool</code> \u2192 boolean - <code>int</code>, <code>float</code> \u2192 number - <code>str</code> \u2192 string - <code>list</code> \u2192 array - <code>dict</code> \u2192 object</p> <p>JSONata to Python: - null \u2192 <code>None</code> - boolean \u2192 <code>bool</code> - number \u2192 <code>int</code> or <code>float</code> - string \u2192 <code>str</code> - array \u2192 <code>list</code> - object \u2192 <code>dict</code></p>"},{"location":"api/#evaluate_jsonjson_str-bindingsnone","title":"<code>evaluate_json(json_str, bindings=None)</code>","text":"<p>Evaluate with JSON string input/output for maximum performance.</p> <p>Parameters: - <code>json_str</code> (str): Input data as JSON string - <code>bindings</code> (Optional[Dict[str, Any]]): Optional variable bindings</p> <p>Returns: <code>str</code> - Result as JSON string</p> <p>Raises: <code>ValueError</code> - If JSON parsing or evaluation fails</p> <p>Example: <pre><code>import json\n\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\ndata = {\"items\": [{\"name\": \"A\", \"price\": 150}]}\n\njson_str = json.dumps(data)\nresult_str = expr.evaluate_json(json_str)\nresult = json.loads(result_str)\n</code></pre></p> <p>Use for: - Large datasets (1000+ items) - High-frequency evaluation - Data already in JSON format - Performance-critical code</p>"},{"location":"api/#module-attributes","title":"Module Attributes","text":""},{"location":"api/#__version__","title":"<code>__version__</code>","text":"<p>Package version.</p> <pre><code>print(jsonatapy.__version__)  # \"2.1.0\"\n</code></pre>"},{"location":"api/#__jsonata_version__","title":"<code>__jsonata_version__</code>","text":"<p>JSONata specification version supported.</p> <pre><code>print(jsonatapy.__jsonata_version__)  # \"2.1.0\"\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>All functions raise <code>ValueError</code> with descriptive messages on errors.</p> <p>Parse Error: <pre><code>try:\n    expr = jsonatapy.compile(\"invalid [[ syntax\")\nexcept ValueError as e:\n    print(f\"Parse error: {e}\")\n</code></pre></p> <p>Evaluation Error: <pre><code>try:\n    result = jsonatapy.evaluate(\"$undefined_func()\", {})\nexcept ValueError as e:\n    print(f\"Evaluation error: {e}\")\n</code></pre></p> <p>Safe Evaluation: <pre><code>def safe_evaluate(expression, data, default=None):\n    try:\n        return jsonatapy.evaluate(expression, data)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return default\n</code></pre></p>"},{"location":"api/#thread-safety","title":"Thread Safety","text":"<p>jsonatapy is thread-safe: - Multiple threads can call functions concurrently - <code>JsonataExpression</code> objects can be shared across threads - Evaluation is stateless (except for bindings)</p> <p>Example: <pre><code>from concurrent.futures import ThreadPoolExecutor\n\nexpr = jsonatapy.compile(\"items[price &gt; 100].name\")\n\ndef process(data):\n    return expr.evaluate(data)\n\nwith ThreadPoolExecutor(max_workers=10) as executor:\n    results = executor.map(process, data_list)\n</code></pre></p>"},{"location":"api/#performance-tips","title":"Performance Tips","text":"<p>Compile once, evaluate many times: <pre><code># Slow\nfor data in dataset:\n    result = jsonatapy.evaluate(\"items[price &gt; 100]\", data)\n\n# Fast\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\nfor data in dataset:\n    result = expr.evaluate(data)\n</code></pre></p> <p>Use JSON string API for large data: <pre><code>expr = jsonatapy.compile(\"items[price &gt; 100]\")\njson_str = json.dumps(large_data)\nresult_str = expr.evaluate_json(json_str)\nresult = json.loads(result_str)\n</code></pre></p>"},{"location":"api/#complete-example","title":"Complete Example","text":"<pre><code>import jsonatapy\nimport json\n\ndata = {\n    \"invoice\": {\n        \"number\": \"INV-001\",\n        \"items\": [\n            {\"product\": \"Widget\", \"quantity\": 5, \"price\": 12.50},\n            {\"product\": \"Gadget\", \"quantity\": 2, \"price\": 45.00},\n            {\"product\": \"Doohickey\", \"quantity\": 10, \"price\": 3.25}\n        ]\n    }\n}\n\n# Simple query\ninvoice_num = jsonatapy.evaluate(\"invoice.number\", data)\n\n# Filtering and mapping\nexpr = jsonatapy.compile('''\n    invoice.items[price &gt; 10].{\n        \"product\": product,\n        \"total\": quantity * price\n    }\n''')\nexpensive_items = expr.evaluate(data)\n\n# Aggregation\ntotal = jsonatapy.evaluate(\"$sum(invoice.items.(quantity * price))\", data)\n\n# With bindings\nexpr = jsonatapy.compile(\"invoice.items[price &gt; $threshold].product\")\nresult = expr.evaluate(data, {\"threshold\": 20})\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>jsonatapy includes a comprehensive benchmark suite comparing performance across multiple JSONata implementations.</p>"},{"location":"benchmarks/#running-benchmarks","title":"Running Benchmarks","text":"<pre><code># Build jsonatapy\nmaturin develop --release\n\n# Install benchmark dependencies\nuv sync --extra bench\n\n# Run full benchmark suite\nuv run python benchmarks/python/benchmark.py\n\n# Update docs/performance.md with latest results\nuv run python benchmarks/update_docs.py\n</code></pre>"},{"location":"benchmarks/#implementations-compared","title":"Implementations Compared","text":"<p>Latest benchmark results (2026-02-21) compare:</p> <ol> <li>jsonatapy - Rust-based Python extension (this project), <code>evaluate(dict)</code> path</li> <li>jsonatapy (rust-only) - Same library, <code>evaluate_json(str)</code> path (bypasses Python object conversion)</li> <li>jsonata-js - Official JavaScript reference implementation (Node.js v24.13.1)</li> <li>jsonata-python - Pure Python implementation</li> <li>jsonata-rs - Pure Rust CLI implementation (optional, requires building the binary)</li> </ol> <p>To include jsonata-rs in benchmarks: <pre><code>cd benchmarks/rust\ncargo build --release\n</code></pre></p>"},{"location":"benchmarks/#benchmark-categories","title":"Benchmark Categories","text":"<ul> <li>Simple Paths - Basic field access and arithmetic (<code>name</code>, <code>a.b.c</code>, <code>x + y</code>)</li> <li>Array Operations - Aggregation and filtering on arrays of scalars and objects</li> <li>Complex Transformations - Object construction, conditionals, nested function calls</li> <li>Deep Nesting - Paths 12+ levels deep, nested array access</li> <li>String Operations - <code>$uppercase</code>, <code>$substring</code>, <code>$contains</code>, etc.</li> <li>Higher-Order Functions - <code>$map</code>, <code>$filter</code>, <code>$reduce</code> with lambdas</li> <li>Realistic Workload - E-commerce dataset queries: filter, aggregate, transform, sort</li> <li>Path Comparison - Same expressions across all four evaluation paths (<code>evaluate</code>, <code>evaluate_json</code>, <code>evaluate_with_data</code>, <code>evaluate_data_to_json</code>)</li> </ul>"},{"location":"benchmarks/#results","title":"Results","text":"<p>See Performance for detailed benchmark results, charts, and analysis of the performance characteristics of each category.</p>"},{"location":"benchmarks/#pure-rust-criterion-benchmarks","title":"Pure-Rust Criterion Benchmarks","text":"<p>The Python benchmark suite measures end-to-end performance including the Python\u2194Rust boundary cost. To measure the Rust evaluator in isolation \u2014 with no Python interpreter, no PyO3, no GIL, no object conversion \u2014 the crate includes a Criterion benchmark suite.</p> <p>This is the most direct measure of what <code>jsonata-core</code> costs as a Rust library.</p>"},{"location":"benchmarks/#running","title":"Running","text":"<pre><code>cargo bench --no-default-features --features simd\n</code></pre> <p>Results are written to <code>target/criterion/</code>. Open <code>target/criterion/report/index.html</code> for the full HTML report.</p>"},{"location":"benchmarks/#what-is-measured","title":"What is measured","text":"<p>Each benchmark parses the expression once (outside the timed loop), then measures repeated <code>Evaluator::new().evaluate(&amp;ast, &amp;data)</code> calls using Criterion's statistical framework (outlier detection, confidence intervals, automatically tuned sample count).</p>"},{"location":"benchmarks/#results-release-build-amd-ryzen-intel-core-simd-enabled","title":"Results (release build, AMD Ryzen / Intel Core, SIMD enabled)","text":"Benchmark Time Simple field lookup (<code>name</code>) 81 ns Deep path 5 levels (<code>a.b.c.d.e</code>) 140 ns Arithmetic (<code>price * quantity</code>) 140 ns Conditional (<code>price &gt; 100 ? \"expensive\" : \"affordable\"</code>) 106 ns String operations (<code>$uppercase</code>, <code>$substring</code>) 126\u2013284 ns <code>$sum</code> (100 elements) 287 ns <code>$sum</code> (1000 elements) 1.88 \u00b5s Filter predicate (100 objects) 7.9 \u00b5s Filter by category (100-product dataset) 9.3 \u00b5s Complex transformation (100-product dataset) 44 \u00b5s <code>$sort</code> / top-rated (100-product dataset) 18 \u00b5s"},{"location":"benchmarks/#comparison-with-jsonata-rs","title":"Comparison with jsonata-rs","text":"<p>jsonata-rs is the only other pure-Rust JSONata implementation. Based on its published benchmarks, <code>jsonata-core</code> is approximately 40x faster across typical workloads:</p> Category jsonata-core jsonata-rs (est.) Simple path lookup 81 ns ~3 \u00b5s <code>$sum</code> (100 elements) 287 ns ~20 \u00b5s Filter predicate (100 objects) 7.9 \u00b5s ~385 \u00b5s <p>The gap comes from <code>jsonata-core</code>'s JValue type (O(1) <code>Rc</code> clones, no heap allocation for common operations) and a compile-once expression cache that eliminates repeated predicate recompilation.</p>"},{"location":"benchmarks/#clarification-rust-only-in-the-python-benchmark-suite","title":"Clarification: \"rust-only\" in the Python benchmark suite","text":"<p>The Python benchmark suite labels the <code>evaluate_json(json_string)</code> path as \"rust-only\". This is not the same as the Criterion benchmarks above. Both paths use the Rust evaluator; the difference is how data enters and exits:</p> <ul> <li><code>evaluate(dict)</code> \u2014 PyO3 walks the Python dict tree \u2192 JValue \u2192 evaluate \u2192 JValue \u2192 Python object</li> <li><code>evaluate_json(str)</code> \u2014 serde_json parses the JSON string \u2192 JValue \u2192 evaluate \u2192 JValue \u2192 serde_json serializes</li> </ul> <p>For small payloads, serde_json parse+serialize overhead can exceed the PyO3 traversal cost, so <code>evaluate_json</code> is sometimes slower than <code>evaluate(dict)</code> on tiny inputs. Neither path eliminates the Python boundary; they just cross it differently.</p> <p>The Criterion benchmarks are the only measurements that eliminate the Python boundary entirely.</p>"},{"location":"benchmarks/#key-findings","title":"Key Findings","text":"<p>jsonatapy is the fastest Python JSONata implementation available, and faster than the JavaScript reference for pure expression workloads. The performance ceiling for array-heavy workloads is set by Python's object model: converting Python dicts to Rust values costs roughly 1\u00b5s per field, which dominates evaluation time for large datasets. The <code>JsonataData</code> API and <code>evaluate_json</code> path avoid this cost.</p>"},{"location":"benchmarks/#custom-benchmarks","title":"Custom Benchmarks","text":"<p>To add new benchmark cases, edit <code>benchmarks/python/benchmark.py</code> and add entries to the benchmark list:</p> <pre><code>{\n    \"name\": \"My custom test\",\n    \"category\": \"Custom\",\n    \"expression\": \"items[price &gt; 100].name\",\n    \"data\": {\"items\": [...]},\n    \"iterations\": 1000,\n    \"warmup\": 100,\n}\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to jsonatapy are documented in this file.</p> <p>For the complete changelog with detailed version history, see CHANGELOG.md in the repository root.</p>"},{"location":"changelog/#latest-changes","title":"Latest Changes","text":"<p>See the full CHANGELOG.md for the complete version history.</p>"},{"location":"changelog/#version-history","title":"Version History","text":"<p>The project follows Semantic Versioning and maintains a detailed changelog following the Keep a Changelog format.</p>"},{"location":"changelog/#jsonata-version-tracking","title":"JSONata Version Tracking","text":"<p>jsonatapy tracks the jsonata-js reference implementation.</p> <p>Current target version: v2.1.0</p>"},{"location":"changelog/#quick-links","title":"Quick Links","text":"<ul> <li>Full Changelog</li> <li>GitHub Releases</li> <li>PyPI Release History</li> </ul>"},{"location":"compatibility/","title":"JSONata Compatibility","text":"<p>jsonatapy aims for 100% compatibility with the JSONata 2.1.0 specification.</p>"},{"location":"compatibility/#test-suite-overview","title":"Test Suite Overview","text":"<p>jsonatapy includes a comprehensive test adapter that runs the complete reference JSONata test suite from the official JavaScript implementation.</p>"},{"location":"compatibility/#reference-test-suite","title":"Reference Test Suite","text":"<ul> <li>Total Tests: 1258</li> <li>Passing: 1258 (100%)</li> <li>Source: Official jsonata-js repository (v2.1.0) at <code>tests/jsonata-js/</code></li> </ul>"},{"location":"compatibility/#current-compatibility-status","title":"Current Compatibility Status","text":"<pre><code># Run full test suite\nuv run pytest tests/python/test_reference_suite.py\n</code></pre> <p>Results show 100% compatibility with the JSONata 2.1.0 specification.</p>"},{"location":"compatibility/#test-groups","title":"Test Groups","text":"<p>The reference suite is organized into 102 test groups covering all aspects of JSONata:</p>"},{"location":"compatibility/#core-functionality","title":"Core Functionality","text":"<ul> <li><code>literals</code> - Literal values (numbers, strings, booleans, null)</li> <li><code>fields</code> - Field access and navigation</li> <li><code>context</code> - Context variable ($)</li> <li><code>variables</code> - Variable bindings</li> <li><code>wildcards</code> - Wildcard selectors</li> </ul>"},{"location":"compatibility/#operators","title":"Operators","text":"<ul> <li><code>comparison-operators</code> - Equality, inequality, less than, greater than</li> <li><code>numeric-operators</code> - Addition, subtraction, multiplication, division, modulo</li> <li><code>boolean-expressions</code> - AND, OR, NOT operations</li> <li><code>string-concat</code> - String concatenation</li> <li><code>conditionals</code> - Ternary operator and if-then-else</li> </ul>"},{"location":"compatibility/#arrays","title":"Arrays","text":"<ul> <li><code>array-constructor</code> - Array construction syntax</li> <li><code>simple-array-selectors</code> - Basic array indexing and slicing</li> <li><code>multiple-array-selectors</code> - Complex array selections</li> <li><code>predicates</code> - Array filtering with predicates</li> <li><code>transforms</code> - Array transformation operations</li> </ul>"},{"location":"compatibility/#functions","title":"Functions","text":"<p>String Functions: - <code>function-string</code> - $string() - <code>function-substring</code> - $substring() - <code>function-uppercase</code> - $uppercase() - <code>function-lowercase</code> - $lowercase() - <code>function-trim</code> - $trim() - <code>function-length</code> - $length() - <code>function-split</code> - $split() - <code>function-join</code> - $join() - And more...</p> <p>Numeric Functions: - <code>function-number</code> - $number() - <code>function-abs</code> - $abs() - <code>function-floor</code> - $floor() - <code>function-ceil</code> - $ceil() - <code>function-round</code> - $round() - <code>function-sqrt</code> - $sqrt() - <code>function-power</code> - $power() - And more...</p> <p>Array Functions: - <code>function-count</code> - $count() - <code>function-sum</code> - $sum() - <code>function-max</code> - $max() - <code>function-min</code> - $min() - <code>function-average</code> - $average() - <code>function-append</code> - $append() - <code>function-reverse</code> - $reverse() - <code>function-sort</code> - $sort() - <code>function-distinct</code> - $distinct() - And more...</p> <p>Object Functions: - <code>function-keys</code> - $keys() - <code>function-lookup</code> - $lookup() - <code>function-spread</code> - $spread() - <code>function-merge</code> - $merge() - <code>function-exists</code> - $exists() - And more...</p> <p>Higher-Order Functions: - <code>function-map</code> - $map() - <code>function-filter</code> - $filter() - <code>function-reduce</code> - $reduce() - <code>function-single</code> - $single() - <code>function-sift</code> - $sift()</p>"},{"location":"compatibility/#advanced-features","title":"Advanced Features","text":"<ul> <li><code>lambdas</code> - Lambda function syntax</li> <li><code>closures</code> - Closure semantics</li> <li><code>higher-order-functions</code> - Passing functions as arguments</li> <li><code>partial-function-application</code> - Partial application</li> <li><code>tail-recursion</code> - Tail-recursive functions</li> <li><code>regex</code> - Regular expression support</li> <li><code>encoding</code> - Character encoding functions</li> </ul>"},{"location":"compatibility/#error-handling","title":"Error Handling","text":"<ul> <li><code>errors</code> - Error conditions and messages</li> <li><code>missing-paths</code> - Handling undefined paths</li> <li><code>null</code> - Null value handling</li> <li><code>parser-recovery</code> - Parser error recovery</li> </ul>"},{"location":"compatibility/#running-compatibility-tests","title":"Running Compatibility Tests","text":""},{"location":"compatibility/#run-all-tests","title":"Run All Tests","text":"<pre><code>uv run pytest tests/python/test_reference_suite.py -v\n</code></pre>"},{"location":"compatibility/#run-specific-group","title":"Run Specific Group","text":"<pre><code># Run only literal tests\npytest tests/python/test_reference_suite.py -v -k \"literals\"\n\n# Run only string function tests\npytest tests/python/test_reference_suite.py -v -k \"function-string\"\n\n# Run only lambda tests\npytest tests/python/test_reference_suite.py -v -k \"lambdas\"\n</code></pre>"},{"location":"compatibility/#run-with-detailed-output","title":"Run with Detailed Output","text":"<pre><code># Short traceback format\npytest tests/python/test_reference_suite.py -v --tb=short\n\n# Show only first 10 failures\npytest tests/python/test_reference_suite.py -v --maxfail=10\n\n# Show full diff for failures\npytest tests/python/test_reference_suite.py -v --tb=long\n</code></pre>"},{"location":"compatibility/#test-suite-structure","title":"Test Suite Structure","text":"<p>The reference test suite uses JSON-based test specifications:</p> <pre><code>{\n  \"expr\": \"JSONata expression\",\n  \"dataset\": \"dataset0\",\n  \"bindings\": {\"var\": \"value\"},\n  \"result\": &lt;expected result&gt;\n}\n</code></pre> <p>Each test can specify: - <code>result</code>: Expected successful result - <code>undefinedResult</code>: Result should be undefined - <code>code</code>: Expected error code (e.g., \"T2001\") - <code>error</code>: Expected error object - <code>timelimit</code>: Timeout in milliseconds - <code>depth</code>: Maximum recursion depth</p>"},{"location":"compatibility/#improving-compatibility","title":"Improving Compatibility","text":"<p>If you find a compatibility issue:</p> <ol> <li> <p>Run the specific test group to isolate the problem:    <pre><code>pytest tests/python/test_reference_suite.py -v -k \"group_name\"\n</code></pre></p> </li> <li> <p>Check the test case in <code>tests/jsonata-js/test/test-suite/groups/group_name/</code></p> </li> <li> <p>File an issue on GitHub with:</p> </li> <li>Test group and case number</li> <li>Expression that fails</li> <li>Expected vs actual result</li> <li> <p>Error message (if any)</p> </li> <li> <p>Submit a PR with the fix:</p> </li> <li>Update Rust implementation</li> <li>Verify test passes</li> <li>Run full suite to check for regressions</li> </ol>"},{"location":"compatibility/#resources","title":"Resources","text":"<ul> <li>Reference Implementation: https://github.com/jsonata-js/jsonata</li> <li>JSONata Specification: https://docs.jsonata.org/</li> <li>Test Suite Source: <code>tests/jsonata-js/test/test-suite/</code></li> <li>JSONata Exerciser: https://try.jsonata.org/ (for testing expressions)</li> </ul>"},{"location":"credits/","title":"Credits","text":"<p>jsonatapy stands on the shoulders of giants. This page acknowledges the projects, people, and communities that made this work possible.</p>"},{"location":"credits/#jsonata-project","title":"JSONata Project","text":""},{"location":"credits/#original-jsonata","title":"Original JSONata","text":"<p>Created by: Andrew Coleman</p> <p>The JSONata project is the foundational work that defined the JSONata query and transformation language. Andrew Coleman's vision of a lightweight, functional language for JSON processing has enabled countless data transformation use cases.</p> <ul> <li>Website: jsonata.org</li> <li>Documentation: docs.jsonata.org</li> <li>Interactive Playground: try.jsonata.org</li> </ul>"},{"location":"credits/#javascript-reference-implementation","title":"JavaScript Reference Implementation","text":"<p>Repository: jsonata-js</p> <p>The JavaScript reference implementation (jsonata-js) serves as the authoritative specification for JSONata behavior. jsonatapy mirrors this implementation to ensure 100% compatibility.</p> <p>License: MIT</p>"},{"location":"credits/#jsonatapy-contributors","title":"jsonatapy Contributors","text":""},{"location":"credits/#core-team","title":"Core Team","text":"<p>Thank you to all contributors who have helped build jsonatapy:</p> <ul> <li>Contributors list will be maintained as the project grows</li> <li>See GitHub Contributors for the complete list</li> </ul>"},{"location":"credits/#community","title":"Community","text":"<p>Special thanks to: - Early adopters who provided feedback - Beta testers who helped find and fix issues - Documentation contributors - Bug reporters and issue triagers</p>"},{"location":"credits/#technology-stack","title":"Technology Stack","text":""},{"location":"credits/#rust-programming-language","title":"Rust Programming Language","text":"<p>jsonatapy is built with Rust, providing: - Memory safety without garbage collection - Zero-cost abstractions - Fearless concurrency - Excellent performance</p> <p>License: Apache 2.0 / MIT</p>"},{"location":"credits/#pyo3","title":"PyO3","text":"<p>PyO3 enables seamless Rust-Python interoperability: - Native Python extension modules from Rust - Zero-overhead Python API - Automatic type conversions - Excellent tooling and documentation</p> <p>Repository: github.com/PyO3/pyo3</p> <p>License: Apache 2.0 / MIT</p>"},{"location":"credits/#maturin","title":"Maturin","text":"<p>Maturin simplifies building and publishing Python packages written in Rust: - Easy build configuration - Multi-platform wheel building - PyPI publishing integration - Development mode support</p> <p>Repository: github.com/PyO3/maturin</p> <p>License: Apache 2.0 / MIT</p>"},{"location":"credits/#open-source-dependencies","title":"Open Source Dependencies","text":"<p>jsonatapy relies on excellent open-source libraries:</p>"},{"location":"credits/#rust-crates","title":"Rust Crates","text":"<ul> <li>serde &amp; serde_json - Serialization framework</li> <li>indexmap - Hash map with insertion order</li> <li>regex - Regular expression engine</li> <li>thiserror - Error handling macros</li> </ul> <p>See Cargo.toml for the complete dependency list.</p>"},{"location":"credits/#python-packages","title":"Python Packages","text":"<ul> <li>pytest - Testing framework</li> <li>black - Code formatter</li> <li>ruff - Linter</li> <li>mypy - Type checker</li> </ul>"},{"location":"credits/#inspiration","title":"Inspiration","text":""},{"location":"credits/#similar-projects","title":"Similar Projects","text":"<p>jsonatapy was inspired by:</p> <ul> <li>jsonata-python - First Python wrapper for JSONata (via JavaScript engine)</li> <li>Other language implementations - Go, Java, .NET ports of JSONata</li> <li>jq - Command-line JSON processor that inspired JSONata</li> </ul>"},{"location":"credits/#rust-python-ecosystem","title":"Rust-Python Ecosystem","text":"<p>Examples and patterns from the broader Rust-Python community: - pydantic-core - High-performance validation library - polars - Fast DataFrame library - ruff - Extremely fast Python linter - orjson - Fast JSON library</p> <p>These projects demonstrated the potential of Rust for Python extensions.</p>"},{"location":"credits/#jsonata-community","title":"JSONata Community","text":"<p>Thanks to the broader JSONata community:</p> <ul> <li>Forum participants who answer questions</li> <li>Blog authors who write tutorials</li> <li>Conference speakers who promote JSONata</li> <li>Enterprise users who provide real-world feedback</li> </ul>"},{"location":"credits/#testing","title":"Testing","text":""},{"location":"credits/#reference-test-suite","title":"Reference Test Suite","text":"<p>jsonatapy achieves 100% compatibility by passing all 1258 tests from the jsonata-js reference test suite. This comprehensive test coverage is thanks to the JSONata maintainers' commitment to quality.</p> <p>Location: jsonata-js/test/test-suite</p>"},{"location":"credits/#documentation","title":"Documentation","text":""},{"location":"credits/#resources","title":"Resources","text":"<p>Documentation references and inspiration: - JSONata Language Reference - Rust Book - PyO3 Guide - Python Packaging Guide</p>"},{"location":"credits/#special-thanks","title":"Special Thanks","text":""},{"location":"credits/#development-tools","title":"Development Tools","text":"<ul> <li>GitHub - Repository hosting and CI/CD</li> <li>PyPI - Python package distribution</li> <li>Docs.rs - Rust documentation hosting</li> <li>crates.io - Rust package registry</li> </ul>"},{"location":"credits/#ides-and-editors","title":"IDEs and Editors","text":"<ul> <li>VS Code with rust-analyzer</li> <li>PyCharm for Python development</li> <li>Vim/Neovim with LSP support</li> </ul>"},{"location":"credits/#recognition","title":"Recognition","text":""},{"location":"credits/#performance-achievements","title":"Performance Achievements","text":"<p>jsonatapy achieves 4.5x faster than JavaScript on average, thanks to: - Rust's zero-cost abstractions - Efficient memory management (Rc-wrapped values) - Optimized evaluation strategies - Native compiled code vs interpreted JavaScript</p> <p>This performance enables new use cases and higher throughput applications.</p>"},{"location":"credits/#how-to-contribute","title":"How to Contribute","text":"<p>Want to be part of the credits? See our Contributing Guide to get started!</p>"},{"location":"credits/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>Code contributions - Bug fixes, new features, optimizations</li> <li>Documentation - Tutorials, examples, API docs</li> <li>Testing - Bug reports, test cases, performance testing</li> <li>Community - Help others, write blog posts, give talks</li> </ul>"},{"location":"credits/#contact","title":"Contact","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Email: Contact information (if available)</li> </ul>"},{"location":"credits/#license","title":"License","text":"<p>jsonatapy is released under the MIT License, the same license as the JSONata reference implementation. This ensures maximum compatibility and ease of adoption.</p> <p>See License for full details.</p> <p>Thank you to everyone who has contributed to making jsonatapy possible!</p> <p>If we've missed anyone, please open a PR to update this page.</p>"},{"location":"error-handling/","title":"Error Handling","text":"<p>Comprehensive guide to error handling in jsonatapy.</p>"},{"location":"error-handling/#error-types","title":"Error Types","text":"<p>All jsonatapy errors are raised as Python <code>ValueError</code> exceptions with descriptive messages.</p>"},{"location":"error-handling/#parse-errors","title":"Parse Errors","text":"<p>Raised when JSONata expression syntax is invalid.</p> <pre><code>import jsonatapy\n\ntry:\n    expr = jsonatapy.compile(\"invalid [[ syntax\")\nexcept ValueError as e:\n    print(f\"Parse error: {e}\")\n    # Parse error: Unexpected token at position 9\n</code></pre> <p>Common causes: - Unmatched brackets or parentheses - Invalid operators - Malformed expressions - Incorrect syntax</p>"},{"location":"error-handling/#evaluation-errors","title":"Evaluation Errors","text":"<p>Raised when expression evaluation fails.</p> <pre><code>import jsonatapy\n\ntry:\n    result = jsonatapy.evaluate(\"$undefined_func()\", {})\nexcept ValueError as e:\n    print(f\"Evaluation error: {e}\")\n    # Evaluation error: Unknown function: undefined_func\n</code></pre> <p>Common causes: - Unknown function names - Invalid function arguments - Accessing undefined variables - Runtime type mismatches</p>"},{"location":"error-handling/#type-errors","title":"Type Errors","text":"<p>Raised when operations receive incompatible types.</p> <pre><code>import jsonatapy\n\ntry:\n    result = jsonatapy.evaluate(\"$sum('not a number')\", {})\nexcept ValueError as e:\n    print(f\"Type error: {e}\")\n    # Type error: Argument 1 of function \"sum\" must be an array\n</code></pre> <p>Common causes: - Wrong argument types for functions - Invalid operations on incompatible types - Type conversion failures</p>"},{"location":"error-handling/#common-errors","title":"Common Errors","text":""},{"location":"error-handling/#syntax-errors","title":"Syntax Errors","text":""},{"location":"error-handling/#unmatched-brackets","title":"Unmatched Brackets","text":"<pre><code># Error: Unmatched bracket\njsonatapy.compile(\"items[price &gt; 100\")\n# ValueError: Expected ']' at end of expression\n\n# Correct\njsonatapy.compile(\"items[price &gt; 100]\")\n</code></pre>"},{"location":"error-handling/#invalid-operators","title":"Invalid Operators","text":"<pre><code># Error: Invalid operator\njsonatapy.compile(\"items =&gt; price\")\n# ValueError: Unexpected token '=&gt;' at position 6\n\n# Correct\njsonatapy.compile(\"items ~&gt; $map(function($v) { $v.price })\")\n</code></pre>"},{"location":"error-handling/#malformed-path-expressions","title":"Malformed Path Expressions","text":"<pre><code># Error: Invalid path\njsonatapy.compile(\"..items\")\n# ValueError: Unexpected token '..' at position 0\n\n# Correct\njsonatapy.compile(\"items\")\n</code></pre>"},{"location":"error-handling/#function-errors","title":"Function Errors","text":""},{"location":"error-handling/#unknown-function","title":"Unknown Function","text":"<pre><code># Error: Function doesn't exist\njsonatapy.evaluate(\"$myFunc()\", {})\n# ValueError: Unknown function: myFunc\n\n# Use built-in functions\njsonatapy.evaluate(\"$uppercase('hello')\", {})\n</code></pre>"},{"location":"error-handling/#wrong-argument-count","title":"Wrong Argument Count","text":"<pre><code># Error: Too few arguments\njsonatapy.evaluate(\"$substring('hello')\", {})\n# ValueError: The substring function requires at least 2 arguments\n\n# Provide required arguments\njsonatapy.evaluate(\"$substring('hello', 0, 2)\", {})\n</code></pre>"},{"location":"error-handling/#wrong-argument-type","title":"Wrong Argument Type","text":"<pre><code># Error: Wrong type\njsonatapy.evaluate(\"$sum('not an array')\", {})\n# ValueError: Argument 1 of function \"sum\" must be an array\n\n# Pass correct type\njsonatapy.evaluate(\"$sum([1, 2, 3])\", {})\n</code></pre>"},{"location":"error-handling/#path-errors","title":"Path Errors","text":""},{"location":"error-handling/#non-existent-fields","title":"Non-existent Fields","text":"<pre><code># Returns undefined (None in Python)\nresult = jsonatapy.evaluate(\"missing.field\", {})\nprint(result)  # None\n\n# Use default value pattern\nresult = jsonatapy.evaluate(\"missing.field ? missing.field : 'default'\", {})\nprint(result)  # \"default\"\n</code></pre>"},{"location":"error-handling/#type-mismatch-in-path","title":"Type Mismatch in Path","text":"<pre><code># Cannot access property of non-object\ndata = {\"value\": 123}\njsonatapy.evaluate(\"value.property\", data)\n# Returns None (undefined behavior)\n\n# Check type first\njsonatapy.evaluate(\"$type(value) = 'number' ? value : value.property\", data)\n</code></pre>"},{"location":"error-handling/#json-parsing-errors","title":"JSON Parsing Errors","text":"<p>When using <code>evaluate_json()</code>:</p> <pre><code>import jsonatapy\n\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\n\n# Error: Invalid JSON\ntry:\n    result = expr.evaluate_json(\"not valid json\")\nexcept ValueError as e:\n    print(f\"JSON error: {e}\")\n    # JSON error: expected value at line 1 column 1\n\n# Valid JSON\nimport json\njson_str = json.dumps({\"items\": []})\nresult = expr.evaluate_json(json_str)\n</code></pre>"},{"location":"error-handling/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"error-handling/#basic-try-except","title":"Basic Try-Except","text":"<pre><code>import jsonatapy\n\ndef safe_evaluate(expression, data):\n    \"\"\"Safely evaluate with error handling.\"\"\"\n    try:\n        return jsonatapy.evaluate(expression, data)\n    except ValueError as e:\n        print(f\"JSONata error: {e}\")\n        return None\n</code></pre>"},{"location":"error-handling/#separate-parse-and-evaluation-errors","title":"Separate Parse and Evaluation Errors","text":"<pre><code>import jsonatapy\n\ndef compile_and_evaluate(expression, data):\n    \"\"\"Separate compilation and evaluation errors.\"\"\"\n    try:\n        expr = jsonatapy.compile(expression)\n    except ValueError as e:\n        print(f\"Syntax error in expression: {e}\")\n        return None\n\n    try:\n        return expr.evaluate(data)\n    except ValueError as e:\n        print(f\"Evaluation error: {e}\")\n        return None\n</code></pre>"},{"location":"error-handling/#validation-before-evaluation","title":"Validation Before Evaluation","text":"<pre><code>import jsonatapy\n\ndef validate_expression(expression):\n    \"\"\"Check if expression is syntactically valid.\"\"\"\n    try:\n        jsonatapy.compile(expression)\n        return True, None\n    except ValueError as e:\n        return False, str(e)\n\n# Usage\nis_valid, error = validate_expression(\"items[price &gt; 100]\")\nif is_valid:\n    result = jsonatapy.evaluate(\"items[price &gt; 100]\", data)\nelse:\n    print(f\"Invalid expression: {error}\")\n</code></pre>"},{"location":"error-handling/#default-value-on-error","title":"Default Value on Error","text":"<pre><code>import jsonatapy\n\ndef evaluate_with_default(expression, data, default=None):\n    \"\"\"Evaluate with default value on error.\"\"\"\n    try:\n        return jsonatapy.evaluate(expression, data)\n    except ValueError:\n        return default\n\n# Usage\nresult = evaluate_with_default(\"missing.field\", {}, default=\"N/A\")\nprint(result)  # \"N/A\"\n</code></pre>"},{"location":"error-handling/#logging-errors","title":"Logging Errors","text":"<pre><code>import jsonatapy\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef evaluate_with_logging(expression, data):\n    \"\"\"Evaluate with error logging.\"\"\"\n    try:\n        return jsonatapy.evaluate(expression, data)\n    except ValueError as e:\n        logger.error(f\"JSONata error: {e}\", extra={\n            \"expression\": expression,\n            \"data\": data\n        })\n        raise\n</code></pre>"},{"location":"error-handling/#context-manager-pattern","title":"Context Manager Pattern","text":"<pre><code>import jsonatapy\nfrom contextlib import contextmanager\n\n@contextmanager\ndef jsonata_context(expression):\n    \"\"\"Context manager for JSONata expression.\"\"\"\n    try:\n        expr = jsonatapy.compile(expression)\n        yield expr\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        yield None\n\n# Usage\nwith jsonata_context(\"items[price &gt; 100]\") as expr:\n    if expr:\n        result = expr.evaluate(data)\n</code></pre>"},{"location":"error-handling/#debugging-tips","title":"Debugging Tips","text":""},{"location":"error-handling/#1-test-expression-syntax-first","title":"1. Test Expression Syntax First","text":"<pre><code>import jsonatapy\n\n# Validate syntax before using\nexpression = \"items[price &gt; 100].name\"\ntry:\n    expr = jsonatapy.compile(expression)\n    print(\"Expression is valid\")\nexcept ValueError as e:\n    print(f\"Syntax error: {e}\")\n</code></pre>"},{"location":"error-handling/#2-use-simple-test-data","title":"2. Use Simple Test Data","text":"<pre><code>import jsonatapy\n\n# Test with minimal data\ntest_data = {\"items\": [{\"price\": 150, \"name\": \"Widget\"}]}\nresult = jsonatapy.evaluate(\"items[price &gt; 100].name\", test_data)\nprint(result)  # [\"Widget\"]\n</code></pre>"},{"location":"error-handling/#3-break-down-complex-expressions","title":"3. Break Down Complex Expressions","text":"<pre><code>import jsonatapy\n\ndata = {\"orders\": [{\"total\": 100}, {\"total\": 200}]}\n\n# Test each part separately\nstep1 = jsonatapy.evaluate(\"orders\", data)\nprint(\"Step 1:\", step1)\n\nstep2 = jsonatapy.evaluate(\"orders.total\", data)\nprint(\"Step 2:\", step2)\n\nstep3 = jsonatapy.evaluate(\"$sum(orders.total)\", data)\nprint(\"Step 3:\", step3)\n</code></pre>"},{"location":"error-handling/#4-check-data-types","title":"4. Check Data Types","text":"<pre><code>import jsonatapy\n\n# Verify data structure matches expression\ndata = {\"value\": \"123\"}  # String, not number\n\n# This will return None (undefined)\nresult = jsonatapy.evaluate(\"value &gt; 100\", data)\nprint(result)  # None\n\n# Fix: Convert to number\nresult = jsonatapy.evaluate(\"$number(value) &gt; 100\", data)\nprint(result)  # True\n</code></pre>"},{"location":"error-handling/#5-use-jsonata-playground","title":"5. Use JSONata Playground","text":"<p>Test expressions online first: - Visit try.jsonata.org - Test your expression with sample data - Debug syntax issues before using in Python</p>"},{"location":"error-handling/#6-add-verbose-error-handling","title":"6. Add Verbose Error Handling","text":"<pre><code>import jsonatapy\nimport traceback\n\ndef debug_evaluate(expression, data):\n    \"\"\"Evaluate with detailed error information.\"\"\"\n    print(f\"Expression: {expression}\")\n    print(f\"Data: {data}\")\n\n    try:\n        result = jsonatapy.evaluate(expression, data)\n        print(f\"Result: {result}\")\n        return result\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        traceback.print_exc()\n        return None\n</code></pre>"},{"location":"error-handling/#error-message-examples","title":"Error Message Examples","text":""},{"location":"error-handling/#parse-error-messages","title":"Parse Error Messages","text":"<pre><code>Unexpected token '[' at position 5\nExpected ']' at end of expression\nInvalid number format at position 12\nUnterminated string literal at position 8\n</code></pre>"},{"location":"error-handling/#evaluation-error-messages","title":"Evaluation Error Messages","text":"<pre><code>Unknown function: myFunc\nArgument 1 of function \"sum\" must be an array\nDivision by zero\nCannot access property \"field\" of undefined\nStack overflow (recursion depth exceeded)\n</code></pre>"},{"location":"error-handling/#type-error-messages","title":"Type Error Messages","text":"<pre><code>Cannot convert \"text\" to number\nExpected array, got string\nCannot apply operator '+' to types object and number\n</code></pre>"},{"location":"error-handling/#best-practices","title":"Best Practices","text":""},{"location":"error-handling/#1-fail-fast-during-initialization","title":"1. Fail Fast During Initialization","text":"<pre><code>import jsonatapy\n\nclass DataTransformer:\n    def __init__(self, expression):\n        # Compile at init time to catch syntax errors early\n        self.expr = jsonatapy.compile(expression)\n\n    def transform(self, data):\n        # Only evaluation errors possible here\n        return self.expr.evaluate(data)\n</code></pre>"},{"location":"error-handling/#2-provide-user-friendly-error-messages","title":"2. Provide User-Friendly Error Messages","text":"<pre><code>import jsonatapy\n\ndef user_friendly_evaluate(expression, data):\n    \"\"\"Evaluate with user-friendly error messages.\"\"\"\n    try:\n        return jsonatapy.evaluate(expression, data)\n    except ValueError as e:\n        error_msg = str(e)\n        if \"Unknown function\" in error_msg:\n            return {\"error\": \"The function you used doesn't exist. Check the function name.\"}\n        elif \"Unexpected token\" in error_msg:\n            return {\"error\": \"Your expression has a syntax error. Please check the syntax.\"}\n        else:\n            return {\"error\": f\"An error occurred: {error_msg}\"}\n</code></pre>"},{"location":"error-handling/#3-handle-errors-at-the-right-level","title":"3. Handle Errors at the Right Level","text":"<pre><code>import jsonatapy\n\ndef process_records(records, expression):\n    \"\"\"Process multiple records with per-record error handling.\"\"\"\n    expr = jsonatapy.compile(expression)  # Fail fast if syntax error\n\n    results = []\n    for i, record in enumerate(records):\n        try:\n            result = expr.evaluate(record)\n            results.append({\"success\": True, \"result\": result})\n        except ValueError as e:\n            results.append({\"success\": False, \"error\": str(e), \"record_index\": i})\n\n    return results\n</code></pre>"},{"location":"error-handling/#4-document-expected-errors","title":"4. Document Expected Errors","text":"<pre><code>import jsonatapy\n\ndef transform_data(expression: str, data: dict) -&gt; dict:\n    \"\"\"\n    Transform data using JSONata expression.\n\n    Args:\n        expression: JSONata expression string\n        data: Input data dictionary\n\n    Returns:\n        Transformed data\n\n    Raises:\n        ValueError: If expression syntax is invalid or evaluation fails\n\n    Example:\n        &gt;&gt;&gt; transform_data(\"items[price &gt; 100]\", {\"items\": [...]})\n    \"\"\"\n    return jsonatapy.evaluate(expression, data)\n</code></pre>"},{"location":"error-handling/#next-steps","title":"Next Steps","text":"<ul> <li>Learn optimization tips</li> <li>Review API reference</li> <li>Explore usage patterns</li> <li>Check compatibility notes</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page provides practical examples of using jsonatapy for common tasks.</p>"},{"location":"examples/#basic-queries","title":"Basic Queries","text":""},{"location":"examples/#simple-path-navigation","title":"Simple Path Navigation","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"user\": {\n        \"name\": \"Alice\",\n        \"email\": \"alice@example.com\"\n    }\n}\n\n# Simple path\nresult = jsonatapy.evaluate(\"user.name\", data)\nprint(result)  # \"Alice\"\n\n# Nested path\nresult = jsonatapy.evaluate(\"user.email\", data)\nprint(result)  # \"alice@example.com\"\n</code></pre>"},{"location":"examples/#array-operations","title":"Array Operations","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"products\": [\n        {\"name\": \"Widget\", \"price\": 10.99, \"inStock\": True},\n        {\"name\": \"Gadget\", \"price\": 24.99, \"inStock\": False},\n        {\"name\": \"Doohickey\", \"price\": 5.99, \"inStock\": True}\n    ]\n}\n\n# Filter array\nresult = jsonatapy.evaluate(\"products[inStock]\", data)\n# Returns: [{\"name\": \"Widget\", ...}, {\"name\": \"Doohickey\", ...}]\n\n# Map array\nresult = jsonatapy.evaluate(\"products.name\", data)\n# Returns: [\"Widget\", \"Gadget\", \"Doohickey\"]\n\n# Filter and map\nresult = jsonatapy.evaluate(\"products[price &gt; 10].name\", data)\n# Returns: [\"Gadget\"]\n</code></pre>"},{"location":"examples/#data-transformation","title":"Data Transformation","text":""},{"location":"examples/#object-construction","title":"Object Construction","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"firstName\": \"John\",\n    \"lastName\": \"Doe\",\n    \"age\": 30\n}\n\n# Create new object structure\nexpression = '''\n{\n    \"fullName\": firstName &amp; \" \" &amp; lastName,\n    \"isAdult\": age &gt;= 18\n}\n'''\n\nresult = jsonatapy.evaluate(expression, data)\n# Returns: {\"fullName\": \"John Doe\", \"isAdult\": true}\n</code></pre>"},{"location":"examples/#array-transformation","title":"Array Transformation","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"orders\": [\n        {\"id\": 1, \"total\": 100, \"items\": 3},\n        {\"id\": 2, \"total\": 250, \"items\": 5},\n        {\"id\": 3, \"total\": 75, \"items\": 2}\n    ]\n}\n\n# Transform array\nexpression = '''\norders{\n    \"orderId\": id,\n    \"averagePrice\": total / items\n}\n'''\n\nresult = jsonatapy.evaluate(expression, data)\n</code></pre>"},{"location":"examples/#aggregation","title":"Aggregation","text":""},{"location":"examples/#built-in-aggregation-functions","title":"Built-in Aggregation Functions","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"sales\": [\n        {\"amount\": 100, \"region\": \"North\"},\n        {\"amount\": 200, \"region\": \"South\"},\n        {\"amount\": 150, \"region\": \"North\"}\n    ]\n}\n\n# Sum\ntotal = jsonatapy.evaluate(\"$sum(sales.amount)\", data)\n# Returns: 450\n\n# Average\navg = jsonatapy.evaluate(\"$average(sales.amount)\", data)\n# Returns: 150\n\n# Max\nmax_sale = jsonatapy.evaluate(\"$max(sales.amount)\", data)\n# Returns: 200\n\n# Count\ncount = jsonatapy.evaluate(\"$count(sales)\", data)\n# Returns: 3\n</code></pre>"},{"location":"examples/#grouping-and-aggregation","title":"Grouping and Aggregation","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"sales\": [\n        {\"amount\": 100, \"region\": \"North\"},\n        {\"amount\": 200, \"region\": \"South\"},\n        {\"amount\": 150, \"region\": \"North\"},\n        {\"amount\": 180, \"region\": \"South\"}\n    ]\n}\n\n# Group by region and sum\nexpression = '''\nsales{\n    region: $sum(amount)\n}\n'''\n\nresult = jsonatapy.evaluate(expression, data)\n# Returns: {\"North\": 250, \"South\": 380}\n</code></pre>"},{"location":"examples/#string-operations","title":"String Operations","text":""},{"location":"examples/#string-functions","title":"String Functions","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"text\": \"Hello, World!\"\n}\n\n# Uppercase\nresult = jsonatapy.evaluate(\"$uppercase(text)\", data)\n# Returns: \"HELLO, WORLD!\"\n\n# Lowercase\nresult = jsonatapy.evaluate(\"$lowercase(text)\", data)\n# Returns: \"hello, world!\"\n\n# Substring\nresult = jsonatapy.evaluate(\"$substring(text, 0, 5)\", data)\n# Returns: \"Hello\"\n\n# Contains\nresult = jsonatapy.evaluate(\"$contains(text, 'World')\", data)\n# Returns: true\n\n# String concatenation\nresult = jsonatapy.evaluate(\"text &amp; ' How are you?'\", data)\n# Returns: \"Hello, World! How are you?\"\n</code></pre>"},{"location":"examples/#advanced-features","title":"Advanced Features","text":""},{"location":"examples/#higher-order-functions","title":"Higher-Order Functions","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"numbers\": [1, 2, 3, 4, 5]\n}\n\n# Map with lambda\nresult = jsonatapy.evaluate(\n    \"$map(numbers, function($v) { $v * 2 })\",\n    data\n)\n# Returns: [2, 4, 6, 8, 10]\n\n# Filter with lambda\nresult = jsonatapy.evaluate(\n    \"$filter(numbers, function($v) { $v &gt; 2 })\",\n    data\n)\n# Returns: [3, 4, 5]\n\n# Reduce with lambda\nresult = jsonatapy.evaluate(\n    \"$reduce(numbers, function($acc, $v) { $acc + $v }, 0)\",\n    data\n)\n# Returns: 15\n</code></pre>"},{"location":"examples/#conditional-expressions","title":"Conditional Expressions","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"temperature\": 25,\n    \"unit\": \"C\"\n}\n\n# Ternary operator\nexpression = 'temperature &gt; 30 ? \"Hot\" : \"Comfortable\"'\nresult = jsonatapy.evaluate(expression, data)\n# Returns: \"Comfortable\"\n\n# Nested conditionals\nexpression = '''\ntemperature &gt; 30 ? \"Hot\" :\ntemperature &gt; 20 ? \"Warm\" :\ntemperature &gt; 10 ? \"Cool\" : \"Cold\"\n'''\nresult = jsonatapy.evaluate(expression, data)\n# Returns: \"Warm\"\n</code></pre>"},{"location":"examples/#performance-optimization","title":"Performance Optimization","text":""},{"location":"examples/#using-jsonatadata-handles","title":"Using JsonataData Handles","text":"<p>For repeated queries on the same data, use <code>JsonataData</code> handles to avoid re-parsing the data:</p> <pre><code>import jsonatapy\n\n# Parse data once\ndata_handle = jsonatapy.JsonataData(large_dataset)\n\n# Reuse the parsed data for multiple queries\nexpr1 = jsonatapy.JsonataExpression(\"products[category='Electronics']\")\nresult1 = expr1.evaluate_with_data(data_handle)\n\nexpr2 = jsonatapy.JsonataExpression(\"$sum(products.price)\")\nresult2 = expr2.evaluate_with_data(data_handle)\n\n# Much faster than calling evaluate() multiple times with the same dict\n</code></pre>"},{"location":"examples/#pre-compiling-expressions","title":"Pre-compiling Expressions","text":"<p>For repeated evaluations with different data, pre-compile the expression:</p> <pre><code>import jsonatapy\n\n# Compile once\nexpr = jsonatapy.JsonataExpression(\"products[price &gt; threshold].name\")\n\n# Evaluate multiple times with different data\nfor dataset in datasets:\n    result = expr.evaluate(dataset)\n    print(result)\n</code></pre>"},{"location":"examples/#real-world-example","title":"Real-World Example","text":""},{"location":"examples/#e-commerce-order-processing","title":"E-Commerce Order Processing","text":"<pre><code>import jsonatapy\n\norders_data = {\n    \"orders\": [\n        {\n            \"id\": \"ORD-001\",\n            \"customer\": \"Alice\",\n            \"items\": [\n                {\"product\": \"Widget\", \"price\": 10.99, \"qty\": 2},\n                {\"product\": \"Gadget\", \"price\": 24.99, \"qty\": 1}\n            ],\n            \"status\": \"pending\"\n        },\n        {\n            \"id\": \"ORD-002\",\n            \"customer\": \"Bob\",\n            \"items\": [\n                {\"product\": \"Doohickey\", \"price\": 5.99, \"qty\": 5}\n            ],\n            \"status\": \"shipped\"\n        }\n    ]\n}\n\n# Calculate total value of all orders\nexpression = '''\n{\n    \"totalOrders\": $count(orders),\n    \"totalRevenue\": $sum(orders.items.(price * qty)),\n    \"pendingOrders\": $count(orders[status='pending']),\n    \"averageOrderValue\": $sum(orders.items.(price * qty)) / $count(orders)\n}\n'''\n\nresult = jsonatapy.evaluate(expression, orders_data)\nprint(result)\n# {\n#     \"totalOrders\": 2,\n#     \"totalRevenue\": 76.92,\n#     \"pendingOrders\": 1,\n#     \"averageOrderValue\": 38.46\n# }\n</code></pre>"},{"location":"examples/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>JSONata Language - Language specification</li> <li>Performance - Performance optimization guide</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#quick-install","title":"Quick Install","text":"<pre><code>pip install jsonatapy\n</code></pre> <p>Pre-built wheels available for: - Python: 3.10, 3.11, 3.12, 3.13 - Platforms: Windows (x64), Linux (x86_64, aarch64), macOS (Intel, ARM)</p>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import jsonatapy\n\nprint(jsonatapy.__version__)  # 2.1.0\n\n# Test\ndata = {\"name\": \"World\"}\nresult = jsonatapy.evaluate('\"Hello, \" &amp; name', data)\nprint(result)  # \"Hello, World\"\n</code></pre>"},{"location":"installation/#building-from-source","title":"Building from Source","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ol> <li>Install Rust: https://rustup.rs/</li> <li>Install maturin: <code>pip install maturin</code></li> <li>Python 3.10+ with development headers</li> </ol>"},{"location":"installation/#build","title":"Build","text":"<pre><code>git clone https://github.com/txjmb/jsonata-core.git\ncd jsonatapy\nmaturin develop --release\n</code></pre> <p>See Build Guide for details.</p>"},{"location":"installation/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"installation/#windows","title":"Windows","text":"<p>Requires Visual C++ Redistributable: https://aka.ms/vs/17/release/vc_redist.x64.exe</p>"},{"location":"installation/#macos","title":"macOS","text":"<p>Requires Xcode Command Line Tools: <pre><code>xcode-select --install\n</code></pre></p>"},{"location":"installation/#linux","title":"Linux","text":"<p>For building from source: <pre><code># Ubuntu/Debian\nsudo apt-get install python3-dev build-essential\n\n# Fedora/RHEL\nsudo dnf install python3-devel gcc\n</code></pre></p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#importerror-dll-load-failed-windows","title":"ImportError: DLL load failed (Windows)","text":"<p>Install Visual C++ Redistributable (link above).</p>"},{"location":"installation/#modulenotfounderror-no-module-named-_jsonatapy","title":"ModuleNotFoundError: No module named '_jsonatapy'","text":"<pre><code>pip uninstall jsonatapy\npip install jsonatapy\n</code></pre>"},{"location":"installation/#wheel-not-found-for-your-platform","title":"Wheel not found for your platform","text":"<p>Build from source or file an issue on GitHub.</p>"},{"location":"jsonata-language/","title":"JSONata Language Reference","text":"<p>jsonatapy implements the JSONata query and transformation language for JSON data.</p>"},{"location":"jsonata-language/#what-is-jsonata","title":"What is JSONata?","text":"<p>JSONata is a lightweight query and transformation language for JSON data. Inspired by the 'location path' semantics of XPath 3.1, it allows sophisticated queries to be expressed in a compact and intuitive notation.</p>"},{"location":"jsonata-language/#language-features","title":"Language Features","text":""},{"location":"jsonata-language/#path-expressions","title":"Path Expressions","text":"<p>Navigate through JSON structures using dot notation:</p> <pre><code>user.name\nuser.address.city\nproducts[0].name\n</code></pre>"},{"location":"jsonata-language/#predicates","title":"Predicates","text":"<p>Filter arrays using boolean conditions in square brackets:</p> <pre><code>products[price &gt; 100]\nusers[age &gt;= 18 and status = 'active']\n</code></pre>"},{"location":"jsonata-language/#array-operations","title":"Array Operations","text":"<ul> <li>Mapping: <code>products.name</code> - extract all names</li> <li>Filtering: <code>products[inStock]</code> - filter by condition</li> <li>Flattening: Automatically flattens nested arrays</li> </ul>"},{"location":"jsonata-language/#operators","title":"Operators","text":"<p>Comparison: <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></p> <p>Logical: <code>and</code>, <code>or</code>, <code>not</code></p> <p>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></p> <p>String concatenation: <code>&amp;</code></p> <p>Range: <code>[1..5]</code> - generates <code>[1, 2, 3, 4, 5]</code></p>"},{"location":"jsonata-language/#object-construction","title":"Object Construction","text":"<p>Create new JSON objects:</p> <pre><code>{\n    \"fullName\": firstName &amp; \" \" &amp; lastName,\n    \"age\": age,\n    \"isAdult\": age &gt;= 18\n}\n</code></pre>"},{"location":"jsonata-language/#array-constructors","title":"Array Constructors","text":"<p>Create new arrays:</p> <pre><code>[1, 2, 3]\n[name, age, email]\n</code></pre>"},{"location":"jsonata-language/#built-in-functions","title":"Built-in Functions","text":""},{"location":"jsonata-language/#string-functions","title":"String Functions","text":"<ul> <li><code>$string(arg)</code> - Cast to string</li> <li><code>$length(str)</code> - String length</li> <li><code>$substring(str, start, length?)</code> - Extract substring</li> <li><code>$uppercase(str)</code> - Convert to uppercase</li> <li><code>$lowercase(str)</code> - Convert to lowercase</li> <li><code>$trim(str)</code> - Remove whitespace</li> <li><code>$contains(str, pattern)</code> - Check if contains pattern</li> <li><code>$split(str, separator, limit?)</code> - Split string</li> <li><code>$join(array, separator?)</code> - Join array elements</li> <li><code>$replace(str, pattern, replacement)</code> - Replace pattern</li> </ul>"},{"location":"jsonata-language/#numeric-functions","title":"Numeric Functions","text":"<ul> <li><code>$number(arg)</code> - Cast to number</li> <li><code>$abs(number)</code> - Absolute value</li> <li><code>$floor(number)</code> - Round down</li> <li><code>$ceil(number)</code> - Round up</li> <li><code>$round(number, precision?)</code> - Round to precision</li> <li><code>$power(base, exponent)</code> - Exponentiation</li> <li><code>$sqrt(number)</code> - Square root</li> <li><code>$random()</code> - Random number [0, 1)</li> </ul>"},{"location":"jsonata-language/#array-functions","title":"Array Functions","text":"<ul> <li><code>$count(array)</code> - Count elements</li> <li><code>$sum(array)</code> - Sum numeric elements</li> <li><code>$max(array)</code> - Maximum value</li> <li><code>$min(array)</code> - Minimum value</li> <li><code>$average(array)</code> - Average value</li> <li><code>$append(array1, array2)</code> - Concatenate arrays</li> <li><code>$reverse(array)</code> - Reverse array</li> <li><code>$sort(array, function?)</code> - Sort array</li> <li><code>$distinct(array)</code> - Remove duplicates</li> <li><code>$shuffle(array)</code> - Randomly shuffle</li> </ul>"},{"location":"jsonata-language/#object-functions","title":"Object Functions","text":"<ul> <li><code>$keys(object)</code> - Get object keys</li> <li><code>$lookup(object, key)</code> - Get value by key</li> <li><code>$spread(object)</code> - Spread object into array</li> <li><code>$merge(array)</code> - Merge objects in array</li> <li><code>$sift(object, function)</code> - Filter object properties</li> </ul>"},{"location":"jsonata-language/#higher-order-functions","title":"Higher-Order Functions","text":"<ul> <li><code>$map(array, function)</code> - Transform each element</li> <li><code>$filter(array, function)</code> - Filter elements</li> <li><code>$reduce(array, function, init?)</code> - Reduce to single value</li> <li><code>$each(object, function)</code> - Iterate over object properties</li> </ul>"},{"location":"jsonata-language/#boolean-functions","title":"Boolean Functions","text":"<ul> <li><code>$boolean(arg)</code> - Cast to boolean</li> <li><code>$not(arg)</code> - Logical NOT</li> <li><code>$exists(arg)</code> - Check if exists</li> </ul>"},{"location":"jsonata-language/#other-functions","title":"Other Functions","text":"<ul> <li><code>$type(value)</code> - Get type of value</li> <li><code>$assert(condition, message?)</code> - Assertion</li> </ul>"},{"location":"jsonata-language/#lambda-functions","title":"Lambda Functions","text":"<p>Define anonymous functions:</p> <pre><code>function($x) { $x * 2 }\nfunction($x, $y) { $x + $y }\n</code></pre> <p>Use with higher-order functions:</p> <pre><code>$map(numbers, function($n) { $n * $n })\n$filter(products, function($p) { $p.price &gt; 100 })\n</code></pre>"},{"location":"jsonata-language/#variable-binding","title":"Variable Binding","text":"<p>Bind values to variables for reuse:</p> <pre><code>$total := $sum(items.price);\n$tax := $total * 0.1;\n$total + $tax\n</code></pre>"},{"location":"jsonata-language/#conditional-expressions","title":"Conditional Expressions","text":"<p>Ternary operator:</p> <pre><code>age &gt;= 18 ? \"Adult\" : \"Minor\"\n</code></pre> <p>Nested conditionals:</p> <pre><code>score &gt;= 90 ? \"A\" :\nscore &gt;= 80 ? \"B\" :\nscore &gt;= 70 ? \"C\" : \"F\"\n</code></pre>"},{"location":"jsonata-language/#parent-operator","title":"Parent Operator","text":"<p>Use <code>%</code> to reference parent context in predicates:</p> <pre><code>products[price &gt; %.averagePrice]\n</code></pre>"},{"location":"jsonata-language/#wildcards","title":"Wildcards","text":"<ul> <li><code>*</code> - All properties</li> <li><code>**</code> - Recursive descent (all nested properties)</li> </ul> <pre><code>account.*.balance\naccount.**.balance\n</code></pre>"},{"location":"jsonata-language/#type-system","title":"Type System","text":"<p>JSONata has the following types:</p> <ul> <li>string - Text</li> <li>number - Numeric values (64-bit float)</li> <li>boolean - <code>true</code> or <code>false</code></li> <li>null - Null value</li> <li>array - Ordered collection</li> <li>object - Key-value pairs</li> <li>function - Lambda functions</li> </ul>"},{"location":"jsonata-language/#compatibility","title":"Compatibility","text":"<p>jsonatapy aims for 100% compatibility with the reference JavaScript implementation. Currently:</p> <ul> <li>1258/1258 tests passing (100% compatibility)</li> <li>All language features supported</li> <li>All built-in functions implemented</li> <li>Full lambda and higher-order function support</li> </ul> <p>See Compatibility Status for detailed information.</p>"},{"location":"jsonata-language/#learn-more","title":"Learn More","text":"<ul> <li>Official JSONata Documentation</li> <li>JSONata Exerciser - Interactive playground</li> <li>Examples - Practical examples</li> <li>API Reference - jsonatapy API documentation</li> </ul>"},{"location":"jsonata-language/#differences-from-javascript-implementation","title":"Differences from JavaScript Implementation","text":"<p>jsonatapy is implemented in Rust for performance, but maintains semantic compatibility with the JavaScript reference implementation:</p> <ul> <li>Performance: Typically faster than JavaScript for most operations</li> <li>Type handling: Same type coercion rules as JavaScript</li> <li>Error messages: Similar error messages and stack traces</li> <li>Async: Currently synchronous only (async support planned)</li> </ul> <p>See Performance for benchmarks and optimization tips.</p>"},{"location":"license/","title":"License","text":"<p>jsonatapy is released under the MIT License.</p>"},{"location":"license/#mit-license","title":"MIT License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 jsonatapy contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"license/#what-this-means","title":"What This Means","text":"<p>The MIT License is a permissive open-source license that allows you to:</p> <ul> <li>Use the software commercially</li> <li>Modify the software</li> <li>Distribute the software</li> <li>Sublicense the software</li> <li>Use privately without restrictions</li> </ul>"},{"location":"license/#requirements","title":"Requirements","text":"<p>You must: - Include the copyright notice and license text in all copies - Include the license text in substantial portions of the software</p>"},{"location":"license/#limitations","title":"Limitations","text":"<p>The software is provided \"as is\", without warranty of any kind. The authors are not liable for any damages arising from the use of the software.</p>"},{"location":"license/#related-licenses","title":"Related Licenses","text":""},{"location":"license/#jsonata-reference-implementation","title":"JSONata Reference Implementation","text":"<p>The jsonata-js reference implementation is also MIT licensed, ensuring compatibility and alignment with the original project.</p>"},{"location":"license/#dependencies","title":"Dependencies","text":"<p>jsonatapy uses the following open-source libraries:</p> <p>Rust Dependencies: - PyO3 - Apache 2.0 / MIT License - serde - Apache 2.0 / MIT License - serde_json - Apache 2.0 / MIT License - indexmap - Apache 2.0 / MIT License - regex - Apache 2.0 / MIT License</p> <p>All dependencies use permissive licenses compatible with MIT.</p>"},{"location":"license/#full-license-text","title":"Full License Text","text":"<p>For the complete license text, see LICENSE in the repository root.</p>"},{"location":"license/#questions","title":"Questions?","text":"<p>If you have questions about licensing: - Review the MIT License FAQ - Open an issue on GitHub - Check the Open Source Initiative resources</p>"},{"location":"migration-from-js/","title":"Migration from JavaScript jsonata","text":"<p>Guide for migrating from the JavaScript jsonata library to jsonatapy.</p>"},{"location":"migration-from-js/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>API Mapping</li> <li>Key Differences</li> <li>Code Examples</li> <li>Performance Considerations</li> <li>Common Pitfalls</li> </ul>"},{"location":"migration-from-js/#overview","title":"Overview","text":"<p>jsonatapy provides 100% JSONata language compatibility with the JavaScript reference implementation. The core JSONata expressions remain the same, but the Python API differs from the JavaScript API.</p>"},{"location":"migration-from-js/#what-stays-the-same","title":"What Stays the Same","text":"<p>-JSONata expression syntax -All built-in functions -Lambda functions and closures -Higher-order functions -Expression semantics and behavior</p>"},{"location":"migration-from-js/#what-changes","title":"What Changes","text":"<p>-API surface (JavaScript vs Python) -Async patterns (JavaScript async vs Python sync) -Custom function registration (different syntax) -Error handling (JavaScript vs Python exceptions)</p>"},{"location":"migration-from-js/#api-mapping","title":"API Mapping","text":""},{"location":"migration-from-js/#basic-evaluation","title":"Basic Evaluation","text":"<p>JavaScript (jsonata-js): <pre><code>const jsonata = require('jsonata');\n\n// One-time evaluation\nconst result = await jsonata('expression').evaluate(data);\n\n// With bindings\nconst result = await jsonata('expression').evaluate(data, bindings);\n</code></pre></p> <p>Python (jsonatapy): <pre><code>import jsonatapy\n\n# One-time evaluation\nresult = jsonatapy.evaluate('expression', data)\n\n# With bindings\nresult = jsonatapy.evaluate('expression', data, bindings)\n</code></pre></p>"},{"location":"migration-from-js/#pre-compilation","title":"Pre-compilation","text":"<p>JavaScript: <pre><code>const jsonata = require('jsonata');\n\n// Compile once\nconst expr = jsonata('items[price &gt; 100]');\n\n// Evaluate many times\nconst result1 = await expr.evaluate(data1);\nconst result2 = await expr.evaluate(data2);\n</code></pre></p> <p>Python: <pre><code>import jsonatapy\n\n# Compile once\nexpr = jsonatapy.compile('items[price &gt; 100]')\n\n# Evaluate many times (synchronous)\nresult1 = expr.evaluate(data1)\nresult2 = expr.evaluate(data2)\n</code></pre></p>"},{"location":"migration-from-js/#custom-function-registration","title":"Custom Function Registration","text":"<p>JavaScript: <pre><code>const jsonata = require('jsonata');\n\nconst expr = jsonata('$myFunc(value)');\n\n// Register custom function\nexpr.registerFunction('myFunc', (val) =&gt; {\n    return val.toUpperCase();\n}, '&lt;s:s&gt;');  // Signature: string -&gt; string\n\nconst result = await expr.evaluate(data);\n</code></pre></p> <p>Python: <pre><code>import jsonatapy\n\n# Custom functions not yet supported\n# Use bindings as workaround for constants/data\nexpr = jsonatapy.compile('$uppercase(value)')\nresult = expr.evaluate(data)\n</code></pre></p> <p>Note: Custom function registration is not yet implemented in jsonatapy. For simple cases, use variable bindings. For complex transformations, pre-process data in Python.</p>"},{"location":"migration-from-js/#error-handling","title":"Error Handling","text":"<p>JavaScript: <pre><code>const jsonata = require('jsonata');\n\ntry {\n    const expr = jsonata('invalid [[');\n    const result = await expr.evaluate(data);\n} catch (err) {\n    console.error('Error:', err.message);\n    console.error('Position:', err.position);\n    console.error('Token:', err.token);\n}\n</code></pre></p> <p>Python: <pre><code>import jsonatapy\n\ntry:\n    expr = jsonatapy.compile('invalid [[')\n    result = expr.evaluate(data)\nexcept ValueError as e:\n    print(f'Error: {e}')\n    # Python ValueError with descriptive message\n</code></pre></p>"},{"location":"migration-from-js/#key-differences","title":"Key Differences","text":""},{"location":"migration-from-js/#1-synchronous-vs-asynchronous","title":"1. Synchronous vs Asynchronous","text":"<p>JavaScript: Evaluation returns a Promise (async) <pre><code>const result = await expr.evaluate(data);\n</code></pre></p> <p>Python: Evaluation is synchronous <pre><code>result = expr.evaluate(data)\n</code></pre></p> <p>Performance Tip: Python's synchronous API is actually faster for most use cases. Use threading/multiprocessing for concurrency if needed.</p>"},{"location":"migration-from-js/#2-type-conversions","title":"2. Type Conversions","text":"<p>JavaScript: <pre><code>// JavaScript types\nnull, undefined, boolean, number, string, Array, Object\n\n// JSONata undefined becomes JavaScript undefined\nconst result = await expr.evaluate(data);  // may return undefined\n</code></pre></p> <p>Python: <pre><code># Python types\nNone, bool, int, float, str, list, dict\n\n# JSONata undefined becomes Python None\nresult = expr.evaluate(data)  # may return None\n</code></pre></p> <p>Type mapping:</p> JSONata JavaScript Python <code>null</code> <code>null</code> <code>None</code> <code>undefined</code> <code>undefined</code> <code>None</code> boolean <code>Boolean</code> <code>bool</code> number <code>Number</code> <code>int</code> or <code>float</code> string <code>String</code> <code>str</code> array <code>Array</code> <code>list</code> object <code>Object</code> <code>dict</code>"},{"location":"migration-from-js/#3-module-import","title":"3. Module Import","text":"<p>JavaScript: <pre><code>// CommonJS\nconst jsonata = require('jsonata');\n\n// ES modules\nimport jsonata from 'jsonata';\n</code></pre></p> <p>Python: <pre><code># Standard import\nimport jsonatapy\n\n# Alternative\nfrom jsonatapy import compile, evaluate\n</code></pre></p>"},{"location":"migration-from-js/#4-no-built-in-timeouts","title":"4. No Built-in Timeouts","text":"<p>JavaScript: <pre><code>// Timeout support\nconst expr = jsonata('expression');\nexpr.timeout = 5000;  // 5 seconds\n\ntry {\n    const result = await expr.evaluate(data);\n} catch (err) {\n    if (err.message.includes('timeout')) {\n        console.error('Expression timed out');\n    }\n}\n</code></pre></p> <p>Python: <pre><code># No built-in timeout support\n# Use Python's signal module or threading for timeouts\nimport signal\nimport jsonatapy\n\ndef timeout_handler(signum, frame):\n    raise TimeoutError('Expression timed out')\n\nsignal.signal(signal.SIGALRM, timeout_handler)\nsignal.alarm(5)  # 5 seconds\n\ntry:\n    result = expr.evaluate(data)\nfinally:\n    signal.alarm(0)  # Cancel alarm\n</code></pre></p>"},{"location":"migration-from-js/#code-examples","title":"Code Examples","text":""},{"location":"migration-from-js/#example-1-simple-query","title":"Example 1: Simple Query","text":"<p>JavaScript: <pre><code>const jsonata = require('jsonata');\n\nconst data = {\n    \"invoice\": {\n        \"total\": 150.00,\n        \"items\": [\n            {\"product\": \"Widget\", \"price\": 100},\n            {\"product\": \"Gadget\", \"price\": 50}\n        ]\n    }\n};\n\nconst expr = jsonata('invoice.items[price &gt; 75].product');\nconst result = await expr.evaluate(data);\nconsole.log(result);  // [\"Widget\"]\n</code></pre></p> <p>Python: <pre><code>import jsonatapy\n\ndata = {\n    \"invoice\": {\n        \"total\": 150.00,\n        \"items\": [\n            {\"product\": \"Widget\", \"price\": 100},\n            {\"product\": \"Gadget\", \"price\": 50}\n        ]\n    }\n}\n\nexpr = jsonatapy.compile('invoice.items[price &gt; 75].product')\nresult = expr.evaluate(data)\nprint(result)  # [\"Widget\"]\n</code></pre></p>"},{"location":"migration-from-js/#example-2-aggregation","title":"Example 2: Aggregation","text":"<p>JavaScript: <pre><code>const jsonata = require('jsonata');\n\nconst data = {\n    \"orders\": [\n        {\"amount\": 100}, {\"amount\": 200}, {\"amount\": 150}\n    ]\n};\n\nconst expr = jsonata('$sum(orders.amount)');\nconst result = await expr.evaluate(data);\nconsole.log(result);  // 450\n</code></pre></p> <p>Python: <pre><code>import jsonatapy\n\ndata = {\n    \"orders\": [\n        {\"amount\": 100}, {\"amount\": 200}, {\"amount\": 150}\n    ]\n}\n\nexpr = jsonatapy.compile('$sum(orders.amount)')\nresult = expr.evaluate(data)\nprint(result)  # 450\n</code></pre></p>"},{"location":"migration-from-js/#example-3-object-construction","title":"Example 3: Object Construction","text":"<p>JavaScript: <pre><code>const jsonata = require('jsonata');\n\nconst expr = jsonata(`\n    {\n        \"total\": $sum(items.price),\n        \"count\": $count(items),\n        \"products\": items.name\n    }\n`);\n\nconst result = await expr.evaluate(data);\n</code></pre></p> <p>Python: <pre><code>import jsonatapy\n\nexpr = jsonatapy.compile('''\n    {\n        \"total\": $sum(items.price),\n        \"count\": $count(items),\n        \"products\": items.name\n    }\n''')\n\nresult = expr.evaluate(data)\n</code></pre></p>"},{"location":"migration-from-js/#example-4-lambda-functions","title":"Example 4: Lambda Functions","text":"<p>JavaScript: <pre><code>const jsonata = require('jsonata');\n\nconst expr = jsonata(`\n    items ~&gt; $map(function($i) {\n        {\n            \"name\": $i.name,\n            \"total\": $i.price * $i.quantity\n        }\n    })\n`);\n\nconst result = await expr.evaluate(data);\n</code></pre></p> <p>Python: <pre><code>import jsonatapy\n\nexpr = jsonatapy.compile('''\n    items ~&gt; $map(function($i) {\n        {\n            \"name\": $i.name,\n            \"total\": $i.price * $i.quantity\n        }\n    })\n''')\n\nresult = expr.evaluate(data)\n</code></pre></p>"},{"location":"migration-from-js/#example-5-with-bindings","title":"Example 5: With Bindings","text":"<p>JavaScript: <pre><code>const jsonata = require('jsonata');\n\nconst expr = jsonata('items[price &gt; $threshold]');\nconst result = await expr.evaluate(data, {threshold: 100});\n</code></pre></p> <p>Python: <pre><code>import jsonatapy\n\nexpr = jsonatapy.compile('items[price &gt; $threshold]')\nresult = expr.evaluate(data, {'threshold': 100})\n</code></pre></p>"},{"location":"migration-from-js/#performance-considerations","title":"Performance Considerations","text":""},{"location":"migration-from-js/#speed-comparison","title":"Speed Comparison","text":"<p>jsonatapy is significantly faster than JavaScript jsonata:</p> Operation jsonatapy JavaScript jsonata Speedup Simple paths ~2ms ~20ms 10x faster Arithmetic ~1ms ~14ms 14x faster String ops ~5ms ~40ms 8x faster Filtering ~8ms ~35ms 4.4x faster"},{"location":"migration-from-js/#memory-usage","title":"Memory Usage","text":"<p>JavaScript: - V8 heap overhead - Garbage collection pauses - Higher base memory usage</p> <p>Python: - Native Rust implementation - Minimal overhead - Efficient memory usage</p>"},{"location":"migration-from-js/#optimization-tips","title":"Optimization Tips","text":"<p>1. Pre-compile expressions (both) <pre><code>#Good\nexpr = jsonatapy.compile('expression')\nfor data in datasets:\n    result = expr.evaluate(data)\n</code></pre></p> <p>2. Use JSON string API for large data (Python only) <pre><code>#Python advantage - 10-50x faster\nimport json\njson_str = json.dumps(large_data)\nresult_str = expr.evaluate_json(json_str)\nresult = json.loads(result_str)\n</code></pre></p> <p>3. Batch processing <pre><code>#Efficient in both\nexpr = jsonatapy.compile('items[price &gt; 100]')\nresults = [expr.evaluate(d) for d in batch]\n</code></pre></p>"},{"location":"migration-from-js/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"migration-from-js/#1-forgetting-to-remove-await","title":"1. Forgetting to Remove <code>await</code>","text":"<pre><code>// JavaScript\nconst result = await expr.evaluate(data);\n</code></pre> <pre><code># Python - no await needed\nresult = expr.evaluate(data)  # Synchronous\n</code></pre>"},{"location":"migration-from-js/#2-custom-functions","title":"2. Custom Functions","text":"<pre><code>// JavaScript - supported\nexpr.registerFunction('myFunc', fn, signature);\n</code></pre> <pre><code># Python - not yet supported\n# Workaround: use bindings for constants\nresult = expr.evaluate(data, {'constant': 42})\n</code></pre>"},{"location":"migration-from-js/#3-undefined-handling","title":"3. Undefined Handling","text":"<pre><code>// JavaScript - undefined is distinct from null\nif (result === undefined) { ... }\n</code></pre> <pre><code># Python - both map to None\nif result is None:  # Could be null or undefined\n    ...\n</code></pre>"},{"location":"migration-from-js/#4-error-object-differences","title":"4. Error Object Differences","text":"<pre><code>// JavaScript - detailed error object\ncatch (err) {\n    console.log(err.position);  // Token position\n    console.log(err.token);     // Problematic token\n}\n</code></pre> <pre><code># Python - string message in ValueError\nexcept ValueError as e:\n    print(str(e))  # Error message only\n</code></pre>"},{"location":"migration-from-js/#5-async-patterns","title":"5. Async Patterns","text":"<pre><code>// JavaScript - promise-based\nPromise.all([\n    expr1.evaluate(data),\n    expr2.evaluate(data)\n])\n</code></pre> <pre><code># Python - use threading for concurrency\nfrom concurrent.futures import ThreadPoolExecutor\n\nwith ThreadPoolExecutor() as executor:\n    future1 = executor.submit(expr1.evaluate, data)\n    future2 = executor.submit(expr2.evaluate, data)\n    results = [f.result() for f in [future1, future2]]\n</code></pre>"},{"location":"migration-from-js/#migration-checklist","title":"Migration Checklist","text":"<ul> <li> Replace <code>require('jsonata')</code> with <code>import jsonatapy</code></li> <li> Remove <code>await</code> from evaluate calls</li> <li> Update error handling to use <code>ValueError</code></li> <li> Remove custom function registrations (or use workarounds)</li> <li> Update type checks for <code>undefined</code> \u2192 <code>None</code></li> <li> Replace Promise patterns with threading if needed</li> <li> Consider using <code>evaluate_json()</code> for large data</li> <li> Test expressions with representative data</li> <li> Benchmark performance improvements</li> </ul>"},{"location":"migration-from-js/#next-steps","title":"Next Steps","text":"<ul> <li>Explore optimization tips</li> <li>Review API reference</li> <li>Check performance benchmarks</li> <li>Learn error handling patterns</li> </ul>"},{"location":"migration-from-jsonata-python/","title":"Migration from jsonata-python","text":"<p>Guide for migrating from the jsonata-python wrapper to native jsonatapy.</p>"},{"location":"migration-from-jsonata-python/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Why Migrate</li> <li>API Differences</li> <li>Performance Improvements</li> <li>Migration Examples</li> <li>Compatibility Notes</li> <li>Migration Checklist</li> </ul>"},{"location":"migration-from-jsonata-python/#why-migrate","title":"Why Migrate","text":""},{"location":"migration-from-jsonata-python/#performance-gains","title":"Performance Gains","text":"<p>jsonatapy is 2500x faster than jsonata-python on average:</p> Operation jsonata-python jsonatapy Speedup Simple paths ~500ms ~2ms 250x Arithmetic ~600ms ~1ms 600x String ops ~700ms ~5ms 140x Filtering ~1200ms ~8ms 150x Aggregation ~1500ms ~10ms 150x Average ~900ms ~5ms ~2500x"},{"location":"migration-from-jsonata-python/#why-so-slow","title":"Why So Slow?","text":"<p>jsonata-python uses PyExecJS to embed a JavaScript engine:</p> <ol> <li>JavaScript Bridge Overhead: Every call goes through Python \u2192 JS \u2192 Python</li> <li>Engine Startup Cost: Initializing JS engine on each evaluation</li> <li>Data Serialization: Converting Python \u2194 JavaScript objects</li> <li>No Optimization: Cannot cache or pre-compile effectively</li> </ol>"},{"location":"migration-from-jsonata-python/#jsonatapy-advantages","title":"jsonatapy Advantages","text":"<p>-Native Performance: Pure Rust implementation, no JavaScript -Zero Dependencies: No Node.js, no JS engine required -Pre-compilation: Compile once, evaluate many times -Optimized APIs: JSON string API, pre-converted data handles -100% Compatible: Passes all 1258 reference test suite tests</p>"},{"location":"migration-from-jsonata-python/#api-differences","title":"API Differences","text":""},{"location":"migration-from-jsonata-python/#installation","title":"Installation","text":"<p>jsonata-python: <pre><code>pip install jsonata\n# Also requires Node.js to be installed!\n</code></pre></p> <p>jsonatapy: <pre><code>pip install jsonatapy\n# No additional dependencies\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#basic-evaluation","title":"Basic Evaluation","text":"<p>jsonata-python: <pre><code>import jsonata\n\n# Transform method\nresult = jsonata.transform(data, 'expression')\n</code></pre></p> <p>jsonatapy: <pre><code>import jsonatapy\n\n# Evaluate function\nresult = jsonatapy.evaluate('expression', data)\n</code></pre></p> <p>Key difference: Note the reversed parameter order. jsonata-python uses <code>transform(data, expression)</code>, while jsonatapy uses <code>evaluate(expression, data)</code>.</p>"},{"location":"migration-from-jsonata-python/#pre-compilation","title":"Pre-compilation","text":"<p>jsonata-python: <pre><code>import jsonata\n\n# Limited pre-compilation support\nexpr = jsonata.compile('expression')\nresult = jsonata.evaluate(expr, data)\n</code></pre></p> <p>jsonatapy: <pre><code>import jsonatapy\n\n# Full pre-compilation support\nexpr = jsonatapy.compile('expression')\nresult = expr.evaluate(data)  # Much faster!\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#error-handling","title":"Error Handling","text":"<p>jsonata-python: <pre><code>import jsonata\n\ntry:\n    result = jsonata.transform(data, 'invalid [[')\nexcept Exception as e:  # Generic exception\n    print(e)\n</code></pre></p> <p>jsonatapy: <pre><code>import jsonatapy\n\ntry:\n    result = jsonatapy.evaluate('invalid [[', data)\nexcept ValueError as e:  # Specific exception type\n    print(e)\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#performance-improvements","title":"Performance Improvements","text":""},{"location":"migration-from-jsonata-python/#benchmark-simple-path-query","title":"Benchmark: Simple Path Query","text":"<p>jsonata-python: <pre><code>import jsonata\nimport time\n\ndata = {\"items\": [{\"name\": f\"Item {i}\", \"price\": i} for i in range(1000)]}\n\nstart = time.time()\nfor _ in range(100):\n    result = jsonata.transform(data, 'items[price &gt; 500].name')\nelapsed = time.time() - start\nprint(f\"Time: {elapsed:.2f}s\")  # ~120s (1200ms per iteration)\n</code></pre></p> <p>jsonatapy: <pre><code>import jsonatapy\nimport time\n\ndata = {\"items\": [{\"name\": f\"Item {i}\", \"price\": i} for i in range(1000)]}\n\n# Pre-compile for best performance\nexpr = jsonatapy.compile('items[price &gt; 500].name')\n\nstart = time.time()\nfor _ in range(100):\n    result = expr.evaluate(data)\nelapsed = time.time() - start\nprint(f\"Time: {elapsed:.2f}s\")  # ~0.8s (8ms per iteration)\n\n# 150x faster!\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#benchmark-aggregation","title":"Benchmark: Aggregation","text":"<p>jsonata-python: <pre><code>import jsonata\n\ndata = {\"orders\": [{\"amount\": i} for i in range(1000)]}\n\n# ~1500ms per evaluation\nresult = jsonata.transform(data, '$sum(orders.amount)')\n</code></pre></p> <p>jsonatapy: <pre><code>import jsonatapy\n\ndata = {\"orders\": [{\"amount\": i} for i in range(1000)]}\n\nexpr = jsonatapy.compile('$sum(orders.amount)')\nresult = expr.evaluate(data)  # ~10ms per evaluation\n\n# 150x faster!\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#additional-optimizations","title":"Additional Optimizations","text":"<p>jsonatapy offers optimization strategies not available in jsonata-python:</p> <p>1. JSON String API (10-50x faster than evaluate()) <pre><code>import json\nimport jsonatapy\n\nexpr = jsonatapy.compile('items[price &gt; 100]')\njson_str = json.dumps(large_data)\nresult_str = expr.evaluate_json(json_str)  # Super fast!\nresult = json.loads(result_str)\n</code></pre></p> <p>2. Pre-converted Data Handles <pre><code>import jsonatapy\n\n# Convert once\ndata_handle = jsonatapy.JsonataData(data)\n\n# Reuse for multiple queries\nresult1 = expr1.evaluate_with_data(data_handle)\nresult2 = expr2.evaluate_with_data(data_handle)\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#migration-examples","title":"Migration Examples","text":""},{"location":"migration-from-jsonata-python/#example-1-simple-transformation","title":"Example 1: Simple Transformation","text":"<p>Before (jsonata-python): <pre><code>import jsonata\n\ndata = {\n    \"orders\": [\n        {\"product\": \"Widget\", \"quantity\": 2, \"price\": 10},\n        {\"product\": \"Gadget\", \"quantity\": 1, \"price\": 25}\n    ]\n}\n\nresult = jsonata.transform(data, 'orders.{ \"item\": product, \"total\": quantity * price }')\n</code></pre></p> <p>After (jsonatapy): <pre><code>import jsonatapy\n\ndata = {\n    \"orders\": [\n        {\"product\": \"Widget\", \"quantity\": 2, \"price\": 10},\n        {\"product\": \"Gadget\", \"quantity\": 1, \"price\": 25}\n    ]\n}\n\n# Note: parameters reversed\nresult = jsonatapy.evaluate('orders.{ \"item\": product, \"total\": quantity * price }', data)\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#example-2-filtering","title":"Example 2: Filtering","text":"<p>Before (jsonata-python): <pre><code>import jsonata\n\ndef get_expensive_items(data):\n    return jsonata.transform(data, 'items[price &gt; 100]')\n</code></pre></p> <p>After (jsonatapy): <pre><code>import jsonatapy\n\n# Pre-compile for better performance\nEXPENSIVE_ITEMS_EXPR = jsonatapy.compile('items[price &gt; 100]')\n\ndef get_expensive_items(data):\n    return EXPENSIVE_ITEMS_EXPR.evaluate(data)\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#example-3-aggregation","title":"Example 3: Aggregation","text":"<p>Before (jsonata-python): <pre><code>import jsonata\n\ndef calculate_totals(invoice_data):\n    total = jsonata.transform(invoice_data, '$sum(items.(quantity * price))')\n    count = jsonata.transform(invoice_data, '$count(items)')\n    return {\"total\": total, \"count\": count}\n</code></pre></p> <p>After (jsonatapy): <pre><code>import jsonatapy\n\n# Pre-compile both expressions\nTOTAL_EXPR = jsonatapy.compile('$sum(items.(quantity * price))')\nCOUNT_EXPR = jsonatapy.compile('$count(items)')\n\ndef calculate_totals(invoice_data):\n    total = TOTAL_EXPR.evaluate(invoice_data)\n    count = COUNT_EXPR.evaluate(invoice_data)\n    return {\"total\": total, \"count\": count}\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#example-4-api-endpoint","title":"Example 4: API Endpoint","text":"<p>Before (jsonata-python): <pre><code>from flask import Flask, request, jsonify\nimport jsonata\n\napp = Flask(__name__)\n\n@app.route('/transform', methods=['POST'])\ndef transform():\n    data = request.json['data']\n    expression = request.json['expression']\n\n    try:\n        result = jsonata.transform(data, expression)  # Slow!\n        return jsonify({\"result\": result})\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 400\n</code></pre></p> <p>After (jsonatapy): <pre><code>from flask import Flask, request, jsonify\nimport jsonatapy\n\napp = Flask(__name__)\n\n@app.route('/transform', methods=['POST'])\ndef transform():\n    data = request.json['data']\n    expression = request.json['expression']\n\n    try:\n        # Much faster!\n        result = jsonatapy.evaluate(expression, data)\n        return jsonify({\"result\": result})\n    except ValueError as e:\n        return jsonify({\"error\": str(e)}), 400\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#example-5-batch-processing","title":"Example 5: Batch Processing","text":"<p>Before (jsonata-python): <pre><code>import jsonata\n\ndef process_records(records, expression_str):\n    results = []\n    for record in records:\n        result = jsonata.transform(record, expression_str)\n        results.append(result)\n    return results\n\n# Very slow for large batches\nrecords = [{\"value\": i} for i in range(1000)]\nresults = process_records(records, '$uppercase(value)')  # ~100 seconds!\n</code></pre></p> <p>After (jsonatapy): <pre><code>import jsonatapy\n\ndef process_records(records, expression_str):\n    # Compile once\n    expr = jsonatapy.compile(expression_str)\n\n    results = []\n    for record in records:\n        result = expr.evaluate(record)\n        results.append(result)\n    return results\n\n# Much faster\nrecords = [{\"value\": i} for i in range(1000)]\nresults = process_records(records, 'value * 2')  # ~0.2 seconds!\n\n# 500x faster!\n</code></pre></p>"},{"location":"migration-from-jsonata-python/#compatibility-notes","title":"Compatibility Notes","text":""},{"location":"migration-from-jsonata-python/#full-language-compatibility","title":"Full Language Compatibility","text":"<p>jsonatapy implements 100% of the JSONata 2.1.0 specification:</p> <p>-All built-in functions (40+) -Lambda functions and closures -Higher-order functions ($map, $filter, $reduce, etc.) -Object construction and transformation -Array operations and predicates -String, numeric, and boolean operations -Aggregation functions -Date/time functions</p>"},{"location":"migration-from-jsonata-python/#test-suite-compatibility","title":"Test Suite Compatibility","text":"<p>jsonatapy passes 1258/1258 (100%) of the official JSONata reference test suite.</p>"},{"location":"migration-from-jsonata-python/#no-breaking-changes-to-jsonata-syntax","title":"No Breaking Changes to JSONata Syntax","text":"<p>Your existing JSONata expressions work without modification:</p> <pre><code># These expressions work identically in both libraries\nexpressions = [\n    'items[price &gt; 100]',\n    '$sum(orders.total)',\n    'orders ~&gt; $map(function($o) { $o.total })',\n    '{ \"total\": $sum(items.price), \"count\": $count(items) }',\n    '$filter(items, function($i) { $i.price &gt; $threshold })'\n]\n\n# All work the same way - just change the API call\n</code></pre>"},{"location":"migration-from-jsonata-python/#migration-checklist","title":"Migration Checklist","text":""},{"location":"migration-from-jsonata-python/#1-update-dependencies","title":"1. Update Dependencies","text":"<pre><code># Remove old package\npip uninstall jsonata\n\n# Install new package\npip install jsonatapy\n</code></pre>"},{"location":"migration-from-jsonata-python/#2-update-imports","title":"2. Update Imports","text":"<pre><code># Before\nimport jsonata\n\n# After\nimport jsonatapy\n</code></pre>"},{"location":"migration-from-jsonata-python/#3-update-api-calls","title":"3. Update API Calls","text":"<pre><code># Before\nresult = jsonata.transform(data, 'expression')\n\n# After\nresult = jsonatapy.evaluate('expression', data)\n</code></pre>"},{"location":"migration-from-jsonata-python/#4-pre-compile-expressions","title":"4. Pre-compile Expressions","text":"<pre><code># Before - no real benefit\nexpr = jsonata.compile('expression')\nresult = jsonata.evaluate(expr, data)\n\n# After - huge performance gain\nexpr = jsonatapy.compile('expression')\nresult = expr.evaluate(data)\n</code></pre>"},{"location":"migration-from-jsonata-python/#5-update-error-handling","title":"5. Update Error Handling","text":"<pre><code># Before\ntry:\n    result = jsonata.transform(data, expr)\nexcept Exception as e:\n    handle_error(e)\n\n# After\ntry:\n    result = jsonatapy.evaluate(expr, data)\nexcept ValueError as e:\n    handle_error(e)\n</code></pre>"},{"location":"migration-from-jsonata-python/#6-optimize-hot-paths","title":"6. Optimize Hot Paths","text":"<pre><code># Use JSON string API for large data\nimport json\njson_str = json.dumps(large_data)\nresult_str = expr.evaluate_json(json_str)\n\n# Use data handles for multiple queries\ndata_handle = jsonatapy.JsonataData(data)\nresult1 = expr1.evaluate_with_data(data_handle)\nresult2 = expr2.evaluate_with_data(data_handle)\n</code></pre>"},{"location":"migration-from-jsonata-python/#7-test-thoroughly","title":"7. Test Thoroughly","text":"<pre><code># Verify results match\nimport jsonata  # Old library\nimport jsonatapy  # New library\n\ndata = {\"test\": \"data\"}\nexpression = 'test expression'\n\nold_result = jsonata.transform(data, expression)\nnew_result = jsonatapy.evaluate(expression, data)\n\nassert old_result == new_result, \"Results don't match!\"\n</code></pre>"},{"location":"migration-from-jsonata-python/#8-benchmark-performance","title":"8. Benchmark Performance","text":"<pre><code>import time\nimport jsonatapy\n\nexpr = jsonatapy.compile('your expression')\n\nstart = time.time()\nfor _ in range(1000):\n    result = expr.evaluate(data)\nelapsed = time.time() - start\n\nprint(f\"Average: {elapsed/1000*1000:.2f}ms per evaluation\")\n</code></pre>"},{"location":"migration-from-jsonata-python/#complete-migration-example","title":"Complete Migration Example","text":"<p>Before (jsonata-python): <pre><code>import jsonata\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/api/orders', methods=['POST'])\ndef process_orders():\n    try:\n        data = request.json\n\n        # Filter orders\n        filtered = jsonata.transform(data, 'orders[total &gt; 100]')\n\n        # Calculate statistics\n        total = jsonata.transform(data, '$sum(orders.total)')\n        count = jsonata.transform(data, '$count(orders)')\n        average = jsonata.transform(data, '$average(orders.total)')\n\n        return jsonify({\n            \"filtered\": filtered,\n            \"statistics\": {\n                \"total\": total,\n                \"count\": count,\n                \"average\": average\n            }\n        })\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 400\n</code></pre></p> <p>After (jsonatapy): <pre><code>import jsonatapy\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Pre-compile all expressions at startup\nFILTER_EXPR = jsonatapy.compile('orders[total &gt; 100]')\nTOTAL_EXPR = jsonatapy.compile('$sum(orders.total)')\nCOUNT_EXPR = jsonatapy.compile('$count(orders)')\nAVG_EXPR = jsonatapy.compile('$average(orders.total)')\n\n@app.route('/api/orders', methods=['POST'])\ndef process_orders():\n    try:\n        data = request.json\n\n        # Use pre-compiled expressions (much faster!)\n        filtered = FILTER_EXPR.evaluate(data)\n        total = TOTAL_EXPR.evaluate(data)\n        count = COUNT_EXPR.evaluate(data)\n        average = AVG_EXPR.evaluate(data)\n\n        return jsonify({\n            \"filtered\": filtered,\n            \"statistics\": {\n                \"total\": total,\n                \"count\": count,\n                \"average\": average\n            }\n        })\n    except ValueError as e:\n        return jsonify({\"error\": str(e)}), 400\n</code></pre></p> <p>Performance improvement: 100-500x faster!</p>"},{"location":"migration-from-jsonata-python/#next-steps","title":"Next Steps","text":"<ul> <li>Learn optimization tips</li> <li>Review API reference</li> <li>Check performance benchmarks</li> <li>Explore usage patterns</li> </ul>"},{"location":"optimization-tips/","title":"Optimization Tips","text":"<p>Best practices for maximizing jsonatapy performance.</p>"},{"location":"optimization-tips/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Wins</li> <li>Pre-compilation Strategies</li> <li>Data Format Optimization</li> <li>Expression Patterns</li> <li>Memory Management</li> <li>Advanced Techniques</li> </ul>"},{"location":"optimization-tips/#quick-wins","title":"Quick Wins","text":""},{"location":"optimization-tips/#1-compile-once-evaluate-many-times","title":"1. Compile Once, Evaluate Many Times","text":"<p>Impact: 10-1000x faster for repeated evaluations</p> <pre><code>import jsonatapy\n\n# Slow - compiles every time\nfor record in records:\n    result = jsonatapy.evaluate(\"items[price &gt; 100]\", record)\n\n# Fast - compile once\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\nfor record in records:\n    result = expr.evaluate(record)\n</code></pre> <p>When to use: - Same expression used multiple times - Processing streams of data - API endpoints with fixed transformations - ETL pipelines</p>"},{"location":"optimization-tips/#2-use-jsonatadata-for-repeated-queries","title":"2. Use JsonataData for Repeated Queries","text":"<p>Impact: Eliminates Python-to-Rust conversion overhead</p> <pre><code>import jsonatapy\n\n# Convert data once\ndata = jsonatapy.JsonataData(large_dataset)\n\n# Reuse data handle for multiple expressions\nexpr1 = jsonatapy.compile(\"orders[total &gt; 100]\")\nexpr2 = jsonatapy.compile(\"$sum(orders.total)\")\n\nresult1 = expr1.evaluate_with_data(data)\nresult2 = expr2.evaluate_with_data(data)\n</code></pre> <p>When to use: - Multiple expressions on same data - Dashboard queries with shared data - Interactive data exploration</p>"},{"location":"optimization-tips/#3-use-json-string-api-when-data-is-already-json","title":"3. Use JSON String API When Data is Already JSON","text":"<p>Impact: Avoids Python object creation cost; best when data comes from a file, HTTP response, or database as a raw JSON string</p> <pre><code>import jsonatapy\n\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\n\n# Skip json.loads() entirely \u2014 pass the raw string directly\nresult_str = expr.evaluate_json(raw_json_string)\n</code></pre> <p>When to use: - Data arrives as a JSON string (HTTP response body, file contents) and you haven't deserialized it yet - Result can be consumed as a JSON string downstream</p> <p>Note: If you've already called <code>json.loads()</code> on your data, <code>evaluate_json()</code> offers no advantage over <code>evaluate()</code> \u2014 both pay a similar conversion cost. Use <code>JsonataData</code> instead.</p>"},{"location":"optimization-tips/#4-fastest-path-pre-converted-data-json-output","title":"4. Fastest Path: Pre-converted Data + JSON Output","text":"<p>Impact: Maximum performance, zero conversion overhead</p> <pre><code>import json\nimport jsonatapy\n\n# Convert data once from JSON\ndata = jsonatapy.JsonataData.from_json(json_str)\n\n# Compile expression once\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\n\n# Evaluate with zero overhead\nresult_str = expr.evaluate_data_to_json(data)\nresult = json.loads(result_str)\n</code></pre> <p>When to use: - Performance-critical hot paths - Maximum throughput scenarios - Real-time data processing</p>"},{"location":"optimization-tips/#pre-compilation-strategies","title":"Pre-compilation Strategies","text":""},{"location":"optimization-tips/#module-level-compilation","title":"Module-Level Compilation","text":"<pre><code>import jsonatapy\n\n# Compile at module load time\nFILTER_EXPENSIVE = jsonatapy.compile(\"items[price &gt; 100]\")\nCALCULATE_TOTAL = jsonatapy.compile(\"$sum(items.(quantity * price))\")\nEXTRACT_NAMES = jsonatapy.compile(\"items.name\")\n\ndef process_order(order_data):\n    \"\"\"Process order with pre-compiled expressions.\"\"\"\n    expensive = FILTER_EXPENSIVE.evaluate(order_data)\n    total = CALCULATE_TOTAL.evaluate(order_data)\n    names = EXTRACT_NAMES.evaluate(order_data)\n    return {\"expensive\": expensive, \"total\": total, \"names\": names}\n</code></pre>"},{"location":"optimization-tips/#class-based-expression-management","title":"Class-Based Expression Management","text":"<pre><code>import jsonatapy\n\nclass OrderProcessor:\n    \"\"\"Encapsulate expressions for order processing.\"\"\"\n\n    def __init__(self):\n        # Compile all expressions at initialization\n        self.filter_expr = jsonatapy.compile(\"orders[total &gt; $threshold]\")\n        self.sum_expr = jsonatapy.compile(\"$sum(orders.total)\")\n        self.group_expr = jsonatapy.compile(\"orders^(region)\")\n\n    def filter_orders(self, data, threshold):\n        return self.filter_expr.evaluate(data, {\"threshold\": threshold})\n\n    def calculate_total(self, data):\n        return self.sum_expr.evaluate(data)\n\n    def group_by_region(self, data):\n        return self.group_expr.evaluate(data)\n\n# Initialize once\nprocessor = OrderProcessor()\n\n# Use many times\nresult1 = processor.filter_orders(data1, 1000)\nresult2 = processor.filter_orders(data2, 2000)\n</code></pre>"},{"location":"optimization-tips/#expression-registry-pattern","title":"Expression Registry Pattern","text":"<pre><code>import jsonatapy\n\nclass ExpressionRegistry:\n    \"\"\"Registry for pre-compiled expressions.\"\"\"\n\n    def __init__(self):\n        self._expressions = {}\n\n    def register(self, name, expression_str):\n        \"\"\"Register and compile expression.\"\"\"\n        self._expressions[name] = jsonatapy.compile(expression_str)\n\n    def evaluate(self, name, data, bindings=None):\n        \"\"\"Evaluate registered expression.\"\"\"\n        return self._expressions[name].evaluate(data, bindings)\n\n# Setup\nregistry = ExpressionRegistry()\nregistry.register(\"filter\", \"items[price &gt; 100]\")\nregistry.register(\"sum\", \"$sum(items.price)\")\n\n# Use\nresult = registry.evaluate(\"filter\", data)\n</code></pre>"},{"location":"optimization-tips/#data-format-optimization","title":"Data Format Optimization","text":""},{"location":"optimization-tips/#choose-the-right-input-format","title":"Choose the Right Input Format","text":"<pre><code>import json\nimport jsonatapy\n\nexpr = jsonatapy.compile(\"products[price &gt; 100]\")\n\n# Benchmark results (100 products, 5 fields each):\n# evaluate(dict):              ~150\u00b5s  (Python\u2192Rust conversion dominates)\n# evaluate_json(json_str):     ~145\u00b5s  (similar \u2014 JSON parse \u2248 dict walk cost)\n# evaluate_with_data(handle):   ~25\u00b5s  (no input conversion)\n# evaluate_data_to_json(handle): ~14\u00b5s (no conversion either direction)\n\n# For data arriving as a raw JSON string (not yet parsed)\nresult_str = expr.evaluate_json(raw_json_str)   # Skips Python object creation\n\n# For repeated queries on same data \u2014 the real win\ndata_handle = jsonatapy.JsonataData(data)\nresult1 = expr.evaluate_with_data(data_handle)  # ~6x faster than evaluate(dict)\nresult2 = expr.evaluate_with_data(data_handle)  # Same speed \u2014 no re-conversion\n</code></pre>"},{"location":"optimization-tips/#benchmark-your-use-case","title":"Benchmark Your Use Case","text":"<pre><code>import time\nimport json\nimport jsonatapy\n\ndef benchmark(name, func, iterations=100):\n    start = time.time()\n    for _ in range(iterations):\n        func()\n    elapsed = (time.time() - start) / iterations\n    print(f\"{name}: {elapsed*1000:.2f}ms\")\n\ndata = {\"items\": [{\"price\": i} for i in range(1000)]}\njson_str = json.dumps(data)\ndata_handle = jsonatapy.JsonataData(data)\n\nexpr = jsonatapy.compile(\"items[price &gt; 500]\")\n\nbenchmark(\"evaluate()\", lambda: expr.evaluate(data))\nbenchmark(\"evaluate_json()\", lambda: expr.evaluate_json(json_str))\nbenchmark(\"evaluate_with_data()\", lambda: expr.evaluate_with_data(data_handle))\n</code></pre>"},{"location":"optimization-tips/#expression-patterns","title":"Expression Patterns","text":""},{"location":"optimization-tips/#use-path-expressions-instead-of-higher-order-functions","title":"Use Path Expressions Instead of Higher-Order Functions","text":"<pre><code>import jsonatapy\n\n#Slower - higher-order function\nexpr = jsonatapy.compile(\"$map(items, function($i) { $i.name })\")\n\n#Faster - path expression\nexpr = jsonatapy.compile(\"items.name\")\n</code></pre>"},{"location":"optimization-tips/#combine-operations-in-single-expression","title":"Combine Operations in Single Expression","text":"<pre><code>import jsonatapy\n\n#Slower - multiple evaluations\nitems = jsonatapy.evaluate(\"orders.items\", data)\nfiltered = jsonatapy.evaluate(\"items[price &gt; 100]\", {\"items\": items})\nnames = jsonatapy.evaluate(\"items.name\", {\"items\": filtered})\n\n#Faster - single expression\nnames = jsonatapy.evaluate(\"orders.items[price &gt; 100].name\", data)\n</code></pre>"},{"location":"optimization-tips/#use-specialized-predicates","title":"Use Specialized Predicates","text":"<p>Note: Simple field comparisons are optimized internally.</p> <pre><code>import jsonatapy\n\n#Optimized - simple comparison\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\n\n#Optimized - field equality\nexpr = jsonatapy.compile(\"items[category = 'electronics']\")\n\n#Not optimized - complex predicate\nexpr = jsonatapy.compile(\"items[$contains(name, 'widget')]\")\n</code></pre> <p>Predicate optimization applies to: - Simple field comparisons: <code>field &gt; value</code>, <code>field = value</code>, etc. - Direct field access in predicates - Numeric and string comparisons</p> <p>Not optimized: - Function calls in predicates - Complex boolean logic - Nested predicates</p>"},{"location":"optimization-tips/#avoid-deep-nesting","title":"Avoid Deep Nesting","text":"<pre><code>import jsonatapy\n\n#Slower - deeply nested\nexpr = jsonatapy.compile(\"$map($map($map(items, f1), f2), f3)\")\n\n#Faster - flat structure\nexpr = jsonatapy.compile(\"items.{ ... }\")\n</code></pre>"},{"location":"optimization-tips/#pre-filter-before-expensive-operations","title":"Pre-filter Before Expensive Operations","text":"<pre><code>import jsonatapy\n\n#Slower - sorts all items first\nexpr = jsonatapy.compile(\"$sort(items, function($a, $b) { $a.price - $b.price })[0:10]\")\n\n#Faster - filter then sort\nexpr = jsonatapy.compile(\"$sort(items[price &gt; 100], function($a, $b) { $a.price - $b.price })[0:10]\")\n</code></pre>"},{"location":"optimization-tips/#memory-management","title":"Memory Management","text":""},{"location":"optimization-tips/#avoid-creating-large-intermediate-results","title":"Avoid Creating Large Intermediate Results","text":"<pre><code>import jsonatapy\n\n#Creates large intermediate array\nexpr = jsonatapy.compile(\"$map(items, function($i) { $i.details }).$join(', ')\")\n\n#More memory efficient\nexpr = jsonatapy.compile(\"$join(items.details, ', ')\")\n</code></pre>"},{"location":"optimization-tips/#use-streaming-patterns-for-large-datasets","title":"Use Streaming Patterns for Large Datasets","text":"<pre><code>import jsonatapy\nimport json\n\ndef process_large_file(filename, expression_str):\n    \"\"\"Process large JSON file in chunks.\"\"\"\n    expr = jsonatapy.compile(expression_str)\n\n    with open(filename, 'r') as f:\n        # Read line by line if JSONL format\n        for line in f:\n            data = json.loads(line)\n            result = expr.evaluate(data)\n            yield result\n</code></pre>"},{"location":"optimization-tips/#clear-references-to-large-objects","title":"Clear References to Large Objects","text":"<pre><code>import jsonatapy\n\ndef process_batch(data_list):\n    \"\"\"Process batch and release memory.\"\"\"\n    expr = jsonatapy.compile(\"items[price &gt; 100]\")\n    results = []\n\n    for data in data_list:\n        result = expr.evaluate(data)\n        results.append(result)\n        # Data reference released here\n\n    return results\n</code></pre>"},{"location":"optimization-tips/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"optimization-tips/#parallel-processing-with-thread-pool","title":"Parallel Processing with Thread Pool","text":"<pre><code>import jsonatapy\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Compile once (thread-safe)\nexpr = jsonatapy.compile(\"items[price &gt; 100].name\")\n\ndef process_record(data):\n    \"\"\"Process single record.\"\"\"\n    return expr.evaluate(data)\n\n# Process in parallel\nwith ThreadPoolExecutor(max_workers=4) as executor:\n    results = list(executor.map(process_record, data_list))\n</code></pre>"},{"location":"optimization-tips/#caching-results","title":"Caching Results","text":"<pre><code>import jsonatapy\nfrom functools import lru_cache\n\nclass CachedEvaluator:\n    \"\"\"Evaluator with result caching.\"\"\"\n\n    def __init__(self, expression_str):\n        self.expr = jsonatapy.compile(expression_str)\n\n    @lru_cache(maxsize=1000)\n    def evaluate_cached(self, data_json_str):\n        \"\"\"Evaluate with caching (requires hashable input).\"\"\"\n        return self.expr.evaluate_json(data_json_str)\n\n# Usage\nevaluator = CachedEvaluator(\"items[price &gt; 100]\")\n\n# First call - computes result\nresult1 = evaluator.evaluate_cached(json_str1)\n\n# Second call with same input - returns cached result\nresult2 = evaluator.evaluate_cached(json_str1)\n</code></pre>"},{"location":"optimization-tips/#batch-processing-with-jsonatadata","title":"Batch Processing with JsonataData","text":"<pre><code>import jsonatapy\n\ndef process_batch_efficiently(data_list, expressions):\n    \"\"\"Efficiently process multiple expressions on batch of data.\"\"\"\n    # Pre-compile all expressions\n    compiled = [jsonatapy.compile(e) for e in expressions]\n\n    results = []\n    for data in data_list:\n        # Convert data once\n        data_handle = jsonatapy.JsonataData(data)\n\n        # Evaluate all expressions on same data\n        record_results = [\n            expr.evaluate_with_data(data_handle)\n            for expr in compiled\n        ]\n        results.append(record_results)\n\n    return results\n</code></pre>"},{"location":"optimization-tips/#expression-optimization-checklist","title":"Expression Optimization Checklist","text":"<p>Before deploying to production:</p> <ul> <li> Expressions compiled at initialization time</li> <li> Using appropriate data format (evaluate, evaluate_json, or evaluate_with_data)</li> <li> Simple path expressions instead of HOFs where possible</li> <li> Combined operations in single expression</li> <li> Pre-filtering before expensive operations</li> <li> No unnecessary intermediate results</li> <li> Profiled performance on representative data</li> </ul>"},{"location":"optimization-tips/#profiling-example","title":"Profiling Example","text":"<pre><code>import time\nimport json\nimport jsonatapy\n\ndef profile_expression(expression_str, data, iterations=1000):\n    \"\"\"Profile expression performance.\"\"\"\n    # Compilation time\n    start = time.time()\n    expr = jsonatapy.compile(expression_str)\n    compile_time = time.time() - start\n\n    # Evaluation time\n    start = time.time()\n    for _ in range(iterations):\n        result = expr.evaluate(data)\n    eval_time = (time.time() - start) / iterations\n\n    # JSON string evaluation time\n    json_str = json.dumps(data)\n    start = time.time()\n    for _ in range(iterations):\n        result = expr.evaluate_json(json_str)\n    json_time = (time.time() - start) / iterations\n\n    print(f\"Expression: {expression_str}\")\n    print(f\"  Compile time: {compile_time*1000:.2f}ms\")\n    print(f\"  Evaluate time: {eval_time*1000:.3f}ms\")\n    print(f\"  JSON evaluate time: {json_time*1000:.3f}ms\")\n    print(f\"  Speedup: {eval_time/json_time:.1f}x\")\n\n# Example usage\ndata = {\"items\": [{\"price\": i, \"name\": f\"Item {i}\"} for i in range(100)]}\nprofile_expression(\"items[price &gt; 50].name\", data)\n</code></pre>"},{"location":"optimization-tips/#performance-comparison-summary","title":"Performance Comparison Summary","text":"<p>The dominant cost for array-heavy workloads is Python\u2192Rust data conversion (~1\u00b5s per field). Expression evaluation itself is typically 2\u201315\u00b5s regardless of data size.</p> Scenario Method vs <code>evaluate(dict)</code> Notes Any query <code>evaluate(dict)</code> 1x baseline Pays conversion every call Data already as JSON string <code>evaluate_json(str)</code> ~1x Avoids Python objects; similar total cost Same data, multiple queries <code>JsonataData</code> + <code>evaluate_with_data()</code> 6\u201315x faster Conversion paid once Same data, JSON output needed <code>JsonataData.from_json()</code> + <code>evaluate_data_to_json()</code> 10\u201320x faster Zero conversion overhead both ways Simple expressions (paths, math, strings) any of the above already fast jsonatapy beats V8 regardless of path"},{"location":"optimization-tips/#next-steps","title":"Next Steps","text":"<ul> <li>Review error handling patterns</li> <li>Learn migration strategies</li> <li>Explore API reference</li> <li>Check performance benchmarks</li> </ul>"},{"location":"performance/","title":"Performance Benchmarks","text":"<p>jsonatapy is a high-performance Rust implementation of JSONata with Python bindings. This page presents benchmark comparisons against other JSONata implementations.</p>"},{"location":"performance/#implementations-tested","title":"Implementations Tested","text":"Implementation Language Version Description jsonatapy Rust + Python 2.1.0 This project (compiled Rust extension via PyO3) jsonatapy (rust-only) Rust + Python 2.1.0 Same library, JSON string I/O path (bypasses Python object conversion) jsonata-js JavaScript 2.1.0 Reference implementation (Node.js v24.13.1) jsonata-python Python 0.6.1 Pure Python implementation jsonata-rs Rust 0.3 Pure Rust implementation (CLI benchmark, no Python overhead) <p>Benchmarks run on 2026-02-21.</p>"},{"location":"performance/#summary-by-category","title":"Summary by Category","text":"Category jsonatapy vs JS Simple Paths 7.4x faster Array Operations 1.9x slower Complex Transformations 8.3x faster Deep Nesting 1.3x slower String Operations 7.0x faster Higher-Order Functions 2.0x slower Realistic Workload 26.7x slower"},{"location":"performance/#detailed-results","title":"Detailed Results","text":""},{"location":"performance/#simple-paths","title":"Simple Paths","text":"Operation Data Size jsonatapy jsonatapy (rust) jsonata-js jsonata-python jsonata-rs vs JS Simple Path tiny 3.418 4.861 33.450 79.845 69.655 9.8x faster Deep Path (5 levels) tiny 5.267 6.676 23.720 144.328 89.320 4.5x faster Array Index Access 100 elements 8.875 16.370 13.900 175.037 108.928 1.6x faster Arithmetic Expression tiny 2.477 4.368 34.290 96.192 63.679 13.8x faster"},{"location":"performance/#array-operations","title":"Array Operations","text":"Operation Data Size jsonatapy jsonatapy (rust) jsonata-js jsonata-python jsonata-rs vs JS Array Sum (100 elements) 100 elements 1.921 3.446 2.700 99.382 22.349 1.4x faster Array Max (100 elements) 100 elements 2.009 3.560 2.750 105.869 21.035 1.4x faster Array Count (100 elements) 100 elements 3.605 6.585 4.290 78.911 40.881 1.2x faster Array Sum (1000 elements) 1000 elements 3.703 6.153 0.930 168.281 36.927 4.0x slower Array Max (1000 elements) 1000 elements 3.336 5.551 0.910 167.937 30.045 3.7x slower Array Sum (10000 elements) 10000 elements 11.906 16.955 0.090 412.132 84.302 132.3x slower Array Mapping (extract field) 100 objects 46.030 47.858 4.430 383.882 258.456 10.4x slower Array Mapping + Sum 100 objects 44.196 47.854 2.690 448.681 261.346 16.4x slower Array Filtering (predicate) 100 objects 33.973 28.789 1.660 440.762 121.827 20.5x slower"},{"location":"performance/#complex-transformations","title":"Complex Transformations","text":"Operation Data Size jsonatapy jsonatapy (rust) jsonata-js jsonata-python jsonata-rs vs JS Object Construction (simple) tiny 4.104 4.618 15.720 91.767 37.249 3.8x faster Object Construction (nested) tiny 6.143 6.059 15.660 116.394 44.571 2.5x faster Conditional Expression tiny 1.085 1.808 20.090 40.364 30.020 18.5x faster Multiple Nested Functions tiny 1.596 2.211 12.970 69.301 30.505 8.1x faster"},{"location":"performance/#deep-nesting","title":"Deep Nesting","text":"Operation Data Size jsonatapy jsonatapy (rust) jsonata-js jsonata-python jsonata-rs vs JS Deep Path (12 levels) 12 levels 8.188 9.465 10.770 160.139 66.444 1.3x faster Nested Array Access 4-level nested arrays 21.349 32.423 5.090 252.984 128.685 4.2x slower"},{"location":"performance/#string-operations","title":"String Operations","text":"Operation Data Size jsonatapy jsonatapy (rust) jsonata-js jsonata-python jsonata-rs vs JS String Uppercase tiny 2.637 3.903 19.710 94.128 59.715 7.5x faster String Lowercase tiny 2.616 3.845 19.950 93.876 66.215 7.6x faster String Length tiny 2.560 3.965 20.120 93.868 59.884 7.9x faster String Concatenation tiny 2.653 3.187 9.030 99.441 32.199 3.4x faster String Substring tiny 2.114 2.803 12.160 65.012 30.429 5.8x faster String Contains tiny 1.220 2.087 12.420 55.135 30.694 10.2x faster"},{"location":"performance/#higher-order-functions","title":"Higher-Order Functions","text":"Operation Data Size jsonatapy jsonatapy (rust) jsonata-js jsonata-python jsonata-rs vs JS $map with lambda 100 elements 1.787 2.083 0.850 114.098 7.153 2.1x slower $filter with lambda 100 elements 1.636 1.900 0.990 103.713 6.476 1.7x slower $reduce with lambda 100 elements 2.044 2.364 0.850 100.455 7.090 2.4x slower"},{"location":"performance/#realistic-workload","title":"Realistic Workload","text":"Operation Data Size jsonatapy jsonatapy (rust) jsonata-js jsonata-python jsonata-rs vs JS Filter by category 100 products 78.289 74.613 1.880 734.265 384.977 41.6x slower Calculate total value 100 products 71.979 73.042 1.750 652.558 372.265 41.1x slower Complex transformation 100 products 42.814 36.595 4.200 540.489 161.282 10.2x slower Group by category (aggregate) 100 products 43.870 47.985 1.180 618.170 155.178 37.2x slower Top rated products 100 products 17.891 15.873 0.250 199.836 76.446 71.6x slower"},{"location":"performance/#path-comparison","title":"Path Comparison","text":"Operation jsonatapy (ms) Iterations Filter by category (data handle) 12.501 500 Filter by category (data\u2192json) 6.803 500 Complex transformation (data handle) 29.559 500 Complex transformation (data\u2192json) 26.926 500 Aggregate (data handle) 4.506 500 Aggregate (data\u2192json) 4.317 500"},{"location":"performance/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"performance/#where-jsonatapy-excels","title":"Where jsonatapy excels","text":"<p>jsonatapy is the fastest Python JSONata implementation by a wide margin \u2014 50\u2013150x faster than jsonata-python across all categories. It is also faster than jsonata-rs (the leading pure-Rust JSONata implementation) for most workloads, demonstrating that the compilation layer and bytecode VM pay off even without Python overhead.</p> <p>For pure expression evaluation \u2014 simple paths, arithmetic, conditionals, string operations, and complex transformations \u2014 jsonatapy consistently beats the JavaScript reference implementation running on V8:</p> <ul> <li>Simple Paths (7.4x faster)</li> <li>Complex Transformations (8.3x faster)</li> <li>String Operations (7.0x faster)</li> </ul>"},{"location":"performance/#where-javascript-is-faster","title":"Where JavaScript is faster","text":"<p>For workloads that iterate over large arrays of Python dicts, the dominant cost is converting Python objects to Rust values on every <code>evaluate()</code> call \u2014 roughly 1\u00b5s per field, or ~130\u00b5s for 100 objects with 5 fields each. This is a property of the Python/C extension model, not of jsonatapy specifically: any Rust or C extension must pay this cost when reading Python dict data.</p> <ul> <li>Array Operations (1.9x slower overall; aggregates on 100-element arrays are competitive)</li> <li>Higher-Order Functions (2.0x slower)</li> <li>Realistic Workload (26.7x slower on full-conversion path)</li> </ul> <p>V8's JIT compiler eliminates equivalent overhead through type specialisation and loop vectorisation. Without a JIT, this gap is irreducible for the <code>evaluate(dict)</code> call path.</p>"},{"location":"performance/#using-pre-converted-data","title":"Using pre-converted data","text":"<p>With <code>JsonataData</code>, the conversion cost is paid once and amortized across all evaluations. With pre-converted data, the remaining gap to V8 is 2\u20137x \u2014 the pure interpreter vs JIT gap \u2014 which is the practical performance ceiling without adding a JIT compiler.</p> <pre><code>import jsonatapy\n\ndata = {...}  # your data\nexpr = jsonatapy.compile(\"products[price &gt; 100]\")\n\n# Pre-convert once\njdata = jsonatapy.JsonataData(data)\n\n# Reuse many times (6\u201315x faster than evaluate(dict))\nresult = expr.evaluate_with_data(jdata)\n</code></pre>"},{"location":"performance/#methodology","title":"Methodology","text":"<ul> <li>Date: 2026-02-21</li> <li>Platform: Linux (WSL2) on x86_64</li> <li>Python: 3.13</li> <li>Node.js: v24.13.1</li> <li>All times are total wall-clock time for the stated number of iterations</li> <li>Each benchmark includes a warmup phase before measurement</li> <li>'vs JS' column shows jsonatapy speedup relative to the JavaScript reference implementation</li> <li>Values &gt; 1x mean jsonatapy is faster; &lt; 1x means JavaScript is faster</li> </ul>"},{"location":"rust-crate/","title":"jsonata-core (Rust crate)","text":"<p><code>jsonata-core</code> is the pure Rust implementation of JSONata that powers <code>jsonatapy</code>. It is published separately on crates.io for use in Rust projects that don't need Python bindings.</p>"},{"location":"rust-crate/#installation","title":"Installation","text":"<pre><code>[dependencies]\njsonata-core = \"2.1.1\"\n</code></pre> <p>By default this enables SIMD-accelerated JSON parsing. To disable:</p> <pre><code>jsonata-core = { version = \"2.1.1\", default-features = false }\n</code></pre> <p>To enable Python bindings (used internally by <code>jsonatapy</code>):</p> <pre><code>jsonata-core = { version = \"2.1.1\", features = [\"python\"] }\n</code></pre>"},{"location":"rust-crate/#quick-start","title":"Quick start","text":"<pre><code>use jsonata_core::evaluator::Evaluator;\nuse jsonata_core::parser;\nuse jsonata_core::value::JValue;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Parse expression once\n    let ast = parser::parse(\"products[price &gt; 100].name\")?;\n\n    // Build data directly or parse from JSON\n    let data = JValue::from_json_str(r#\"{\n        \"products\": [\n            {\"name\": \"Laptop\", \"price\": 1200},\n            {\"name\": \"Mouse\",  \"price\": 25},\n            {\"name\": \"Monitor\",\"price\": 450}\n        ]\n    }\"#)?;\n\n    // Evaluate\n    let result = Evaluator::new().evaluate(&amp;ast, &amp;data)?;\n    println!(\"{}\", result.to_json_string()?);\n    // [\"Laptop\",\"Monitor\"]\n\n    Ok(())\n}\n</code></pre>"},{"location":"rust-crate/#public-api","title":"Public API","text":""},{"location":"rust-crate/#parserparse","title":"<code>parser::parse</code>","text":"<pre><code>pub fn parse(expression: &amp;str) -&gt; Result&lt;AstNode, ParserError&gt;\n</code></pre> <p>Parses a JSONata expression string into an AST. Parsing is the expensive step \u2014 do it once and reuse the <code>AstNode</code> across many evaluations.</p>"},{"location":"rust-crate/#evaluator","title":"<code>Evaluator</code>","text":"<pre><code>pub struct Evaluator { ... }\n\nimpl Evaluator {\n    pub fn new() -&gt; Self;\n    pub fn with_context(context: Context) -&gt; Self;\n    pub fn evaluate(&amp;mut self, node: &amp;AstNode, data: &amp;JValue)\n        -&gt; Result&lt;JValue, EvaluatorError&gt;;\n}\n</code></pre> <p><code>Evaluator</code> is stateful (holds the scope stack). Construct a fresh one per top-level <code>evaluate()</code> call, or reuse one if you're managing scope manually.</p>"},{"location":"rust-crate/#jvalue","title":"<code>JValue</code>","text":"<p>The runtime value type. All JSONata values are represented as <code>JValue</code>.</p> <pre><code>// Constructors\nJValue::from_json_str(s: &amp;str) -&gt; Result&lt;JValue, ...&gt;  // parse JSON string\nJValue::object(map: IndexMap&lt;String, JValue&gt;) -&gt; JValue\nJValue::array(vec: Vec&lt;JValue&gt;) -&gt; JValue\nJValue::string(s: impl Into&lt;Rc&lt;str&gt;&gt;) -&gt; JValue\nJValue::from(n: f64) -&gt; JValue                          // Number\nJValue::Bool(b: bool)\nJValue::Null\nJValue::Undefined\n\n// Serialisation\nvalue.to_json_string() -&gt; Result&lt;String, ...&gt;\n</code></pre> <p><code>JValue</code> clones are O(1) \u2014 heap variants (<code>String</code>, <code>Array</code>, <code>Object</code>) use <code>Rc</code> reference counting, so cloning shares the allocation.</p>"},{"location":"rust-crate/#context","title":"<code>Context</code>","text":"<pre><code>pub struct Context { ... }\n\nimpl Context {\n    pub fn new() -&gt; Self;\n    pub fn bind(&amp;mut self, name: String, value: JValue);\n}\n</code></pre> <p>Used to inject variable bindings before evaluation:</p> <pre><code>let mut ctx = Context::new();\nctx.bind(\"threshold\".to_string(), JValue::from(100.0));\n\nlet mut ev = Evaluator::with_context(ctx);\nlet result = ev.evaluate(&amp;ast, &amp;data)?;  // $threshold available in expression\n</code></pre>"},{"location":"rust-crate/#performance","title":"Performance","text":"<p>Criterion benchmark results (pure Rust, no Python, release build):</p> Expression Time Simple field lookup 81 ns Arithmetic 140 ns Conditional 106 ns String operations 126\u2013284 ns <code>$sum</code> (100 elements) 287 ns <code>$sum</code> (1000 elements) 1.88 \u00b5s Filter predicate (100 objects) 7.9 \u00b5s Realistic workload (100 products) 9\u201379 \u00b5s <p>Compared to <code>jsonata-rs</code> (the next fastest Rust implementation): ~40x faster across typical workloads.</p> <p>Run benchmarks:</p> <pre><code>git clone https://github.com/txjmb/jsonata-core.git\ncd jsonata-core\ncargo bench --no-default-features --features simd\n</code></pre>"},{"location":"rust-crate/#features","title":"Features","text":"Feature Default Description <code>simd</code> yes SIMD-accelerated JSON parsing via <code>simd-json</code> <code>python</code> no PyO3 Python bindings (used by <code>jsonatapy</code>)"},{"location":"rust-crate/#compatibility","title":"Compatibility","text":"<ul> <li>Rust stable 1.70+</li> <li>Passes all 1258 JSONata 2.1.0 reference tests</li> <li><code>!Send</code> \u2014 uses <code>Rc</code> internally; not safe to send across threads.   For parallel workloads, create one <code>Evaluator</code> per thread.</li> </ul>"},{"location":"usage/","title":"Usage Guide","text":"<p>Common patterns and examples for jsonatapy.</p>"},{"location":"usage/#basic-queries","title":"Basic Queries","text":""},{"location":"usage/#simple-path-access","title":"Simple Path Access","text":"<pre><code>import jsonatapy\n\ndata = {\n    \"user\": {\n        \"name\": \"Alice\",\n        \"email\": \"alice@example.com\"\n    }\n}\n\n# Single field\nresult = jsonatapy.evaluate(\"user.name\", data)\n# \"Alice\"\n\n# Nested field\nresult = jsonatapy.evaluate(\"user.email\", data)\n# \"alice@example.com\"\n</code></pre>"},{"location":"usage/#array-access","title":"Array Access","text":"<pre><code>data = {\n    \"items\": [\"apple\", \"banana\", \"orange\"]\n}\n\n# Single element\nresult = jsonatapy.evaluate(\"items[0]\", data)\n# \"apple\"\n\n# Array slicing\nresult = jsonatapy.evaluate(\"items[1..2]\", data)\n# [\"banana\", \"orange\"]\n</code></pre>"},{"location":"usage/#filtering-and-mapping","title":"Filtering and Mapping","text":""},{"location":"usage/#array-filtering","title":"Array Filtering","text":"<pre><code>data = {\n    \"products\": [\n        {\"name\": \"Laptop\", \"price\": 1200},\n        {\"name\": \"Mouse\", \"price\": 25},\n        {\"name\": \"Keyboard\", \"price\": 75}\n    ]\n}\n\n# Filter by condition\nresult = jsonatapy.evaluate(\"products[price &gt; 50]\", data)\n# [{\"name\": \"Laptop\", \"price\": 1200}, {\"name\": \"Keyboard\", \"price\": 75}]\n\n# Extract specific field\nresult = jsonatapy.evaluate(\"products[price &gt; 50].name\", data)\n# [\"Laptop\", \"Keyboard\"]\n</code></pre>"},{"location":"usage/#array-mapping","title":"Array Mapping","text":"<pre><code># Transform array elements\nresult = jsonatapy.evaluate(\n    'products.{\"item\": name, \"cost\": price}',\n    data\n)\n# [{\"item\": \"Laptop\", \"cost\": 1200}, ...]\n</code></pre>"},{"location":"usage/#aggregation","title":"Aggregation","text":"<pre><code>data = {\n    \"orders\": [\n        {\"quantity\": 2, \"price\": 10},\n        {\"quantity\": 3, \"price\": 15},\n        {\"quantity\": 1, \"price\": 20}\n    ]\n}\n\n# Sum\ntotal = jsonatapy.evaluate(\"$sum(orders.(quantity * price))\", data)\n# 85\n\n# Count\ncount = jsonatapy.evaluate(\"$count(orders)\", data)\n# 3\n\n# Average\navg = jsonatapy.evaluate(\"$average(orders.price)\", data)\n# 15\n\n# Min/Max\nmin_price = jsonatapy.evaluate(\"$min(orders.price)\", data)\nmax_price = jsonatapy.evaluate(\"$max(orders.price)\", data)\n</code></pre>"},{"location":"usage/#string-operations","title":"String Operations","text":"<pre><code>data = {\"name\": \"alice\"}\n\n# Uppercase\nresult = jsonatapy.evaluate(\"$uppercase(name)\", data)\n# \"ALICE\"\n\n# Lowercase\nresult = jsonatapy.evaluate(\"$lowercase(name)\", data)\n# \"alice\"\n\n# Concatenation\nresult = jsonatapy.evaluate('\"Hello, \" &amp; name', data)\n# \"Hello, alice\"\n\n# Substring\nresult = jsonatapy.evaluate('$substring(\"hello\", 1, 4)', {})\n# \"ell\"\n\n# Contains\nresult = jsonatapy.evaluate('$contains(\"hello\", \"ell\")', {})\n# true\n</code></pre>"},{"location":"usage/#conditional-expressions","title":"Conditional Expressions","text":"<pre><code>data = {\"price\": 150}\n\n# Ternary operator\nresult = jsonatapy.evaluate(\n    'price &gt; 100 ? \"expensive\" : \"affordable\"',\n    data\n)\n# \"expensive\"\n\n# Conditional field\nresult = jsonatapy.evaluate(\n    '{\"price\": price, \"category\": price &gt; 100 ? \"premium\" : \"standard\"}',\n    data\n)\n# {\"price\": 150, \"category\": \"premium\"}\n</code></pre>"},{"location":"usage/#object-construction","title":"Object Construction","text":"<pre><code>data = {\n    \"firstName\": \"Alice\",\n    \"lastName\": \"Smith\",\n    \"age\": 30\n}\n\n# Build new object\nresult = jsonatapy.evaluate(\n    '{\"fullName\": firstName &amp; \" \" &amp; lastName, \"age\": age}',\n    data\n)\n# {\"fullName\": \"Alice Smith\", \"age\": 30}\n</code></pre>"},{"location":"usage/#using-bindings","title":"Using Bindings","text":"<pre><code># Define variables\nexpr = jsonatapy.compile(\"items[price &gt; $threshold].name\")\n\nresult = expr.evaluate(\n    {\"items\": [{\"name\": \"A\", \"price\": 100}, {\"name\": \"B\", \"price\": 50}]},\n    {\"threshold\": 75}\n)\n# [\"A\"]\n</code></pre>"},{"location":"usage/#compiled-expressions","title":"Compiled Expressions","text":"<p>For repeated evaluations, compile once:</p> <pre><code>expr = jsonatapy.compile(\"products[category=$cat].name\")\n\n# Evaluate with different data\ndata1 = {\n    \"products\": [\n        {\"name\": \"Item1\", \"category\": \"electronics\"},\n        {\"name\": \"Item2\", \"category\": \"books\"}\n    ]\n}\n\nresult1 = expr.evaluate(data1, {\"cat\": \"electronics\"})\n# [\"Item1\"]\n\nresult2 = expr.evaluate(data1, {\"cat\": \"books\"})\n# [\"Item2\"]\n</code></pre>"},{"location":"usage/#higher-order-functions","title":"Higher-Order Functions","text":""},{"location":"usage/#map","title":"Map","text":"<pre><code>data = {\"numbers\": [1, 2, 3, 4, 5]}\n\nresult = jsonatapy.evaluate(\n    \"$map(numbers, function($n) { $n * 2 })\",\n    data\n)\n# [2, 4, 6, 8, 10]\n</code></pre>"},{"location":"usage/#filter","title":"Filter","text":"<pre><code>result = jsonatapy.evaluate(\n    \"$filter(numbers, function($n) { $n &gt; 3 })\",\n    data\n)\n# [4, 5]\n</code></pre>"},{"location":"usage/#reduce","title":"Reduce","text":"<pre><code>result = jsonatapy.evaluate(\n    \"$reduce(numbers, function($acc, $n) { $acc + $n }, 0)\",\n    data\n)\n# 15\n</code></pre>"},{"location":"usage/#error-handling","title":"Error Handling","text":"<pre><code>def safe_evaluate(expression, data):\n    try:\n        return jsonatapy.evaluate(expression, data)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return None\n\nresult = safe_evaluate(\"invalid[[syntax\", {})\n# Prints: Error: Parse error...\n# Returns: None\n</code></pre>"},{"location":"usage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"usage/#compile-once","title":"Compile Once","text":"<pre><code># Slow - compiles every time\nfor data in dataset:\n    result = jsonatapy.evaluate(\"items[price &gt; 100]\", data)\n\n# Fast - compile once\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\nfor data in dataset:\n    result = expr.evaluate(data)\n</code></pre>"},{"location":"usage/#json-string-api","title":"JSON String API","text":"<p>For large datasets:</p> <pre><code>import json\n\nexpr = jsonatapy.compile(\"items[price &gt; 100]\")\n\n# Large data\ndata = {\"items\": [...]}  # 1000+ items\n\n# Fast path\njson_str = json.dumps(data)\nresult_str = expr.evaluate_json(json_str)\nresult = json.loads(result_str)\n</code></pre>"},{"location":"usage/#real-world-examples","title":"Real-World Examples","text":""},{"location":"usage/#api-response-transformation","title":"API Response Transformation","text":"<pre><code>api_response = {\n    \"data\": {\n        \"user\": {\n            \"id\": 123,\n            \"firstName\": \"Alice\",\n            \"lastName\": \"Smith\",\n            \"orders\": [\n                {\"id\": 1, \"total\": 100},\n                {\"id\": 2, \"total\": 200}\n            ]\n        }\n    }\n}\n\nexpr = jsonatapy.compile('''\n{\n    \"userId\": data.user.id,\n    \"fullName\": data.user.firstName &amp; \" \" &amp; data.user.lastName,\n    \"totalSpent\": $sum(data.user.orders.total)\n}\n''')\n\nresult = expr.evaluate(api_response)\n# {\"userId\": 123, \"fullName\": \"Alice Smith\", \"totalSpent\": 300}\n</code></pre>"},{"location":"usage/#data-filtering-and-grouping","title":"Data Filtering and Grouping","text":"<pre><code>transactions = {\n    \"transactions\": [\n        {\"region\": \"North\", \"amount\": 100},\n        {\"region\": \"South\", \"amount\": 150},\n        {\"region\": \"North\", \"amount\": 200}\n    ]\n}\n\n# Sum by region\nresult = jsonatapy.evaluate(\n    \"$sum(transactions[region='North'].amount)\",\n    transactions\n)\n# 300\n</code></pre>"},{"location":"usage/#etl-pipeline","title":"ETL Pipeline","text":"<pre><code>raw_data = {\n    \"records\": [\n        {\"name\": \"alice\", \"status\": \"active\", \"amount\": 100},\n        {\"name\": \"bob\", \"status\": \"inactive\", \"amount\": 200},\n        {\"name\": \"charlie\", \"status\": \"active\", \"amount\": 150}\n    ]\n}\n\ntransform = jsonatapy.compile('''\nrecords[status=\"active\"].{\n    \"name\": $uppercase(name),\n    \"value\": amount * 1.1\n}\n''')\n\nresult = transform.evaluate(raw_data)\n# [{\"name\": \"ALICE\", \"value\": 110}, {\"name\": \"CHARLIE\", \"value\": 165}]\n</code></pre>"},{"location":"development/architecture/","title":"Architecture","text":"<p>Technical overview of jsonatapy's architecture and design.</p>"},{"location":"development/architecture/#high-level-overview","title":"High-Level Overview","text":"<p>jsonatapy is a Rust-based Python extension implementing the JSONata query and transformation language.</p>"},{"location":"development/architecture/#architecture-layers","title":"Architecture Layers","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Python Application              \u2502\n\u2502         (User Code)                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Python API (python/jsonatapy/)       \u2502\n\u2502    - compile(), evaluate()              \u2502\n\u2502    - JsonataExpression wrapper          \u2502\n\u2502    - JsonataData wrapper                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    PyO3 Bindings (src/lib.rs)           \u2502\n\u2502    - Python\u2194Rust boundary               \u2502\n\u2502    - Type conversions                   \u2502\n\u2502    - Exception handling                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Rust Core                       \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502    \u2502  Parser (src/parser.rs)     \u2502     \u2502\n\u2502    \u2502  - Tokenization             \u2502     \u2502\n\u2502    \u2502  - Expression parsing       \u2502     \u2502\n\u2502    \u2502  - AST generation           \u2502     \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                 \u2502                       \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502    \u2502  Evaluator (src/evaluator.rs)\u2502    \u2502\n\u2502    \u2502  - Expression evaluation    \u2502     \u2502\n\u2502    \u2502  - Context management       \u2502     \u2502\n\u2502    \u2502  - Lambda execution         \u2502     \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                 \u2502                       \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502    \u2502  Functions (src/functions.rs)\u2502    \u2502\n\u2502    \u2502  - Built-in functions       \u2502     \u2502\n\u2502    \u2502  - Datetime (src/datetime.rs)\u2502    \u2502\n\u2502    \u2502  - Signature validation     \u2502     \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#key-components","title":"Key Components","text":"<ol> <li>Python API Layer - User-facing Python interface</li> <li>PyO3 Bindings - Python-Rust interop layer</li> <li>Parser - Converts JSONata expressions to AST</li> <li>Evaluator - Executes AST against data</li> <li>Functions - Built-in function implementations</li> </ol>"},{"location":"development/architecture/#module-structure","title":"Module Structure","text":"<p>jsonatapy mirrors the structure of the JavaScript reference implementation for maintainability.</p> <pre><code>src/\n\u251c\u2500\u2500 lib.rs          # PyO3 bindings, Python API entry point\n\u251c\u2500\u2500 parser.rs       # Expression parser (mirrors parser.js)\n\u251c\u2500\u2500 ast.rs          # AST node definitions\n\u251c\u2500\u2500 evaluator.rs    # Main evaluation engine (mirrors jsonata.js)\n\u251c\u2500\u2500 functions.rs    # Built-in functions (mirrors functions.js)\n\u251c\u2500\u2500 datetime.rs     # Date/time functions (mirrors datetime.js)\n\u251c\u2500\u2500 signature.rs    # Function signature validation (mirrors signature.js)\n\u2514\u2500\u2500 value.rs        # JValue type system (custom to Rust)\n</code></pre>"},{"location":"development/architecture/#module-responsibilities","title":"Module Responsibilities","text":"<p>lib.rs - Python Bindings <pre><code>#[pymodule]\nfn _jsonatapy(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {\n    m.add_function(wrap_pyfunction!(compile, m)?)?;\n    m.add_function(wrap_pyfunction!(evaluate, m)?)?;\n    m.add_class::&lt;JsonataExpression&gt;()?;\n    m.add_class::&lt;JsonataData&gt;()?;\n    Ok(())\n}\n</code></pre></p> <p>parser.rs - Lexical Analysis and Parsing - Tokenizes JSONata expression strings - Builds Abstract Syntax Tree (AST) - Handles operator precedence - Reports syntax errors</p> <p>evaluator.rs - Expression Evaluation (~7500 lines) - Main evaluation engine - Context and scope management - Lambda storage and execution - Path traversal and predicate evaluation - Object construction</p> <p>functions.rs - Built-in Functions - 40+ built-in JSONata functions - String manipulation ($uppercase, $lowercase, \\(substring, etc.) - Array operations (\\)map, $filter, \\(reduce, etc.) - Numeric functions (\\)sum, $average, \\(max, etc.) - Object functions (\\)keys, $values, $merge, etc.)</p> <p>value.rs - Type System - JValue enum representing all JSONata types - Rc-wrapped for O(1) cloning - Conversion to/from Python types</p>"},{"location":"development/architecture/#jvalue-type-system","title":"JValue Type System","text":""},{"location":"development/architecture/#jvalue-enum","title":"JValue Enum","text":"<p>jsonatapy uses a custom <code>JValue</code> type instead of <code>serde_json::Value</code> for performance:</p> <pre><code>pub enum JValue {\n    Null,\n    Bool(bool),\n    Number(f64),\n    String(Rc&lt;str&gt;),              // Rc-wrapped for O(1) clone\n    Array(Rc&lt;Vec&lt;JValue&gt;&gt;),       // Rc-wrapped for O(1) clone\n    Object(Rc&lt;IndexMap&lt;String, JValue&gt;&gt;),  // Rc-wrapped\n    Undefined,                    // JSONata undefined value\n    Lambda {                      // First-class lambda function\n        lambda_id: usize,\n        params: Vec&lt;String&gt;,\n        name: Option&lt;String&gt;,\n        signature: Option&lt;String&gt;,\n    },\n    Builtin {                     // First-class built-in function\n        name: String,\n    },\n    Regex {                       // First-class regex value\n        pattern: String,\n        flags: String,\n    },\n}\n</code></pre>"},{"location":"development/architecture/#key-design-decisions","title":"Key Design Decisions","text":"<p>1. Rc Wrapping for Zero-Copy Cloning</p> <pre><code>// O(1) clone - just increments reference count\nlet s1 = JValue::string(\"hello\");\nlet s2 = s1.clone();  // No data copy\n\n// Compare to String clone: O(n)\nlet s1 = String::from(\"hello\");\nlet s2 = s1.clone();  // Copies entire string\n</code></pre> <p>Impact: 20-100x performance improvement on realistic workloads.</p> <p>2. First-Class Lambda/Builtin/Regex</p> <p>Instead of wrapping in JSON objects:</p> <pre><code>// First-class variant (fast)\nJValue::Lambda { lambda_id: 1, params: vec![], name: None, signature: None }\n\n// Tagged JSON object (slow)\nJValue::Object(map! {\n    \"type\" =&gt; \"lambda\",\n    \"id\" =&gt; 1,\n})\n</code></pre> <p>Impact: Enum discriminant check vs hash map lookup.</p> <p>3. Undefined as Distinct Type</p> <pre><code>// JSONata undefined != null\nJValue::Undefined  // No value (not an error)\nJValue::Null       // Explicit null value\n</code></pre>"},{"location":"development/architecture/#type-conversions","title":"Type Conversions","text":"<p>Python \u2192 JValue: <pre><code>fn from_py(py: Python, obj: &amp;PyAny) -&gt; PyResult&lt;JValue&gt; {\n    if obj.is_none() {\n        Ok(JValue::Null)\n    } else if let Ok(b) = obj.extract::&lt;bool&gt;() {\n        Ok(JValue::Bool(b))\n    } else if let Ok(n) = obj.extract::&lt;f64&gt;() {\n        Ok(JValue::Number(n))\n    // ...\n}\n</code></pre></p> <p>JValue \u2192 Python: <pre><code>fn to_py(&amp;self, py: Python) -&gt; PyResult&lt;PyObject&gt; {\n    match self {\n        JValue::Null =&gt; Ok(py.None()),\n        JValue::Bool(b) =&gt; Ok(b.to_object(py)),\n        JValue::Number(n) =&gt; Ok(n.to_object(py)),\n        JValue::String(s) =&gt; Ok(s.to_object(py)),\n        // ...\n    }\n}\n</code></pre></p>"},{"location":"development/architecture/#evaluation-pipeline","title":"Evaluation Pipeline","text":""},{"location":"development/architecture/#expression-compilation","title":"Expression Compilation","text":"<pre><code>JSONata String  \u2192  Tokenizer  \u2192  Parser  \u2192  AST\n\"items[price&gt;100]\"              \u2192  Node tree\n</code></pre>"},{"location":"development/architecture/#expression-evaluation","title":"Expression Evaluation","text":"<pre><code>AST  \u2192  Evaluator  \u2192  Context  \u2192  Result\n     \u2193\n  Functions\n     \u2193\n  Scope Stack\n</code></pre>"},{"location":"development/architecture/#evaluation-steps","title":"Evaluation Steps","text":"<ol> <li>Parse expression to AST (once)</li> <li>Create evaluation context with data</li> <li>Traverse AST nodes recursively</li> <li>Evaluate each node with context</li> <li>Return result value</li> </ol>"},{"location":"development/architecture/#example-path-expression","title":"Example: Path Expression","text":"<pre><code>// Expression: \"items[price &gt; 100].name\"\n// AST: Path(Identifier(\"items\"),\n//           Predicate(Comparison(field(\"price\"), \"&gt;\", Number(100))),\n//           Identifier(\"name\"))\n\nfn evaluate_path(ctx: &amp;mut Context, path: &amp;PathNode) -&gt; Result&lt;JValue&gt; {\n    // 1. Evaluate base: items\n    let base = evaluate_identifier(ctx, \"items\")?;\n\n    // 2. Apply predicate: [price &gt; 100]\n    let filtered = apply_predicate(base, predicate)?;\n\n    // 3. Extract field: .name\n    let result = extract_field(filtered, \"name\")?;\n\n    Ok(result)\n}\n</code></pre>"},{"location":"development/architecture/#scope-stack-and-lambda-storage","title":"Scope Stack and Lambda Storage","text":""},{"location":"development/architecture/#context-structure","title":"Context Structure","text":"<pre><code>pub struct Context {\n    scopes: Vec&lt;Scope&gt;,          // Stack of scopes\n    lambdas: HashMap&lt;usize, StoredLambda&gt;,  // Lambda storage\n    next_lambda_id: usize,\n}\n\npub struct Scope {\n    bindings: HashMap&lt;String, JValue&gt;,  // Variable bindings\n}\n\npub struct StoredLambda {\n    params: Vec&lt;String&gt;,\n    body: Rc&lt;AstNode&gt;,\n    captured_env: HashMap&lt;String, JValue&gt;,  // Captured variables\n}\n</code></pre>"},{"location":"development/architecture/#scope-management","title":"Scope Management","text":"<p>Push/pop pattern (not clone/restore): <pre><code>// Efficient - push/pop\nctx.push_scope();\nlet result = evaluate_expression(ctx, expr)?;\nctx.pop_scope();\n\n// Inefficient - clone/restore\nlet old_ctx = ctx.clone();\nlet result = evaluate_expression(ctx, expr)?;\n*ctx = old_ctx;\n</code></pre></p>"},{"location":"development/architecture/#lambda-storage","title":"Lambda Storage","text":"<p>Lambdas stored separately from values:</p> <pre><code>// Create lambda\nlet lambda_id = ctx.next_lambda_id();\nlet stored = StoredLambda {\n    params: vec![\"x\".into()],\n    body: Rc::new(body_ast),\n    captured_env: capture_free_vars(ctx, &amp;body_ast),\n};\nctx.lambdas.insert(lambda_id, stored);\n\n// Lambda value\nlet lambda_value = JValue::Lambda {\n    lambda_id,\n    params: vec![\"x\".into()],\n    name: None,\n    signature: None,\n};\n\n// Call lambda\nlet stored = ctx.lambdas.get(&amp;lambda_id).unwrap();\nctx.push_scope_with_bindings(stored.captured_env.clone());\nctx.bind(\"x\", argument);\nlet result = evaluate(ctx, &amp;stored.body)?;\nctx.pop_scope();\n</code></pre>"},{"location":"development/architecture/#selective-capture","title":"Selective Capture","text":"<p>Only capture free variables: <pre><code>fn capture_free_vars(ctx: &amp;Context, body: &amp;AstNode) -&gt; HashMap&lt;String, JValue&gt; {\n    let free_vars = find_free_variables(body);\n    let mut captured = HashMap::new();\n\n    for var in free_vars {\n        if let Some(value) = ctx.lookup(&amp;var) {\n            captured.insert(var, value.clone());\n        }\n    }\n\n    captured\n}\n</code></pre></p>"},{"location":"development/architecture/#performance-optimizations","title":"Performance Optimizations","text":""},{"location":"development/architecture/#applied-optimizations","title":"Applied Optimizations","text":"<ol> <li>Rc-wrapped JValue - O(1) clone (20-100x speedup)</li> <li>First-class Lambda/Builtin/Regex - Enum variants vs hash maps</li> <li>Scope stack push/pop - Instead of HashMap clone</li> <li>Selective lambda capture - Only capture free variables</li> <li>Zero-copy field extraction - Reference-based access</li> <li>Predicate short-circuit - Skip numeric evaluation for booleans</li> <li>Specialized predicates - Optimize simple comparisons</li> <li>Merge sort - O(n log n) sorting algorithm</li> <li>Iterator-based aggregation - Zero-clone \\(sum/\\)max/$min</li> <li>HOF selective args - Only pass needed arguments</li> </ol>"},{"location":"development/architecture/#predicate-optimization","title":"Predicate Optimization","text":"<p>Simple field comparisons are optimized:</p> <pre><code>// Optimized path\nitems[price &gt; 100]      // Direct field comparison\nitems[category = \"A\"]   // Direct field equality\n\n// General path (not optimized)\nitems[$contains(name, \"widget\")]  // Function call\n</code></pre>"},{"location":"development/architecture/#memory-efficiency","title":"Memory Efficiency","text":"<p>Rc sharing prevents unnecessary copies:</p> <pre><code>let data = JValue::array(vec![...]);  // Large array\n\n// Rc increment only - no data copy\nlet filtered = filter_array(&amp;data, predicate)?;\nlet mapped = map_array(&amp;filtered, mapper)?;\nlet sorted = sort_array(&amp;mapped, comparator)?;\n</code></pre>"},{"location":"development/architecture/#key-design-patterns","title":"Key Design Patterns","text":""},{"location":"development/architecture/#1-mirror-javascript-structure","title":"1. Mirror JavaScript Structure","text":"<p>Code organization mirrors jsonata-js for maintainability:</p> <pre><code>JavaScript              Rust\n----------              ----\nparser.js        \u2192      parser.rs\njsonata.js       \u2192      evaluator.rs\nfunctions.js     \u2192      functions.rs\ndatetime.js      \u2192      datetime.rs\nsignature.rs     \u2192      signature.rs\n</code></pre>"},{"location":"development/architecture/#2-pattern-matching-for-type-safety","title":"2. Pattern Matching for Type Safety","text":"<pre><code>match value {\n    JValue::Number(n) =&gt; Ok(n * 2.0),\n    JValue::String(s) =&gt; parse_number(&amp;s),\n    JValue::Array(arr) =&gt; sum_array(&amp;arr),\n    _ =&gt; Err(EvalError::TypeError(\"Expected number\".into())),\n}\n</code></pre>"},{"location":"development/architecture/#3-result-based-error-handling","title":"3. Result-Based Error Handling","text":"<pre><code>pub fn evaluate(ctx: &amp;mut Context, node: &amp;AstNode) -&gt; Result&lt;JValue, EvalError&gt; {\n    match node {\n        AstNode::Number(n) =&gt; Ok(JValue::Number(*n)),\n        AstNode::Path(path) =&gt; evaluate_path(ctx, path),\n        // ...\n    }\n}\n</code></pre>"},{"location":"development/architecture/#4-context-threading","title":"4. Context Threading","text":"<pre><code>// Context passed through call chain\nfn evaluate(ctx: &amp;mut Context, node: &amp;AstNode) -&gt; Result&lt;JValue&gt; {\n    let result = evaluate_child(ctx, child_node)?;\n    // ...\n}\n\nfn evaluate_child(ctx: &amp;mut Context, node: &amp;AstNode) -&gt; Result&lt;JValue&gt; {\n    // Same context, can access bindings/lambdas\n}\n</code></pre>"},{"location":"development/architecture/#5-lazy-evaluation","title":"5. Lazy Evaluation","text":"<pre><code>// Only evaluate branches that are needed\nfn evaluate_conditional(ctx: &amp;mut Context, cond: &amp;AstNode,\n                       then_branch: &amp;AstNode,\n                       else_branch: &amp;AstNode) -&gt; Result&lt;JValue&gt; {\n    let cond_value = evaluate(ctx, cond)?;\n\n    if is_truthy(&amp;cond_value) {\n        evaluate(ctx, then_branch)  // Only evaluate then\n    } else {\n        evaluate(ctx, else_branch)  // Only evaluate else\n    }\n}\n</code></pre>"},{"location":"development/architecture/#testing-strategy","title":"Testing Strategy","text":""},{"location":"development/architecture/#three-layer-testing","title":"Three-Layer Testing","text":"<ol> <li>Rust Unit Tests (31 tests)</li> <li>Test individual functions</li> <li> <p>Located in <code>src/*.rs</code> with <code>#[cfg(test)]</code></p> </li> <li> <p>Python Integration Tests (~50 tests)</p> </li> <li>Test Python API</li> <li> <p>Located in <code>tests/python/</code></p> </li> <li> <p>Reference Test Suite (1258 tests)</p> </li> <li>Official JSONata compatibility tests</li> <li>100% pass rate</li> </ol>"},{"location":"development/architecture/#test-coverage","title":"Test Coverage","text":"<p>Target: 100% coverage (matching upstream jsonata-js)</p>"},{"location":"development/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about testing</li> <li>Understand build process</li> <li>Contribute to the project</li> </ul>"},{"location":"development/building/","title":"Building from Source","text":""},{"location":"development/building/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Rust (latest stable)    <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource $HOME/.cargo/env\n</code></pre></p> </li> <li> <p>Python 3.10+ with development headers    <pre><code># Ubuntu/Debian\nsudo apt-get install python3-dev build-essential\n\n# Fedora/RHEL\nsudo dnf install python3-devel gcc\n\n# macOS\nxcode-select --install\n</code></pre></p> </li> <li> <p>maturin (Rust-Python build tool)    <pre><code>pip install maturin\n</code></pre></p> </li> </ol>"},{"location":"development/building/#quick-build","title":"Quick Build","text":"<pre><code>git clone https://github.com/txjmb/jsonata-core.git\ncd jsonatapy\ngit submodule update --init --recursive\n\n# Development build\nmaturin develop --release\n\n# Run tests\npytest tests/python/ -v\n</code></pre>"},{"location":"development/building/#build-commands","title":"Build Commands","text":"<p>Development mode (for local testing): <pre><code>maturin develop --release\n</code></pre></p> <p>Build wheel: <pre><code>maturin build --release --out dist\n</code></pre></p> <p>Build for specific Python version: <pre><code>maturin build --release --interpreter python3.11\n</code></pre></p> <p>Build for multiple Python versions: <pre><code>maturin build --release --interpreter python3.10 python3.11 python3.12 python3.13\n</code></pre></p>"},{"location":"development/building/#testing","title":"Testing","text":"<p>Python tests: <pre><code># All tests\npytest tests/python/ -v\n\n# Reference suite only\npytest tests/python/test_reference_suite.py -v\n\n# Parallel execution\npytest tests/python/ -n auto\n</code></pre></p> <p>Rust tests: <pre><code>cargo test\ncargo test --release\n</code></pre></p>"},{"location":"development/building/#development-workflow","title":"Development Workflow","text":"<ol> <li>Make changes to Rust code</li> <li>Rebuild: <code>maturin develop --release</code></li> <li>Test: <code>pytest tests/python/ -v</code></li> <li>Format: <code>cargo fmt</code></li> <li>Lint: <code>cargo clippy</code></li> </ol>"},{"location":"development/building/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"development/building/#linux","title":"Linux","text":"<p>For cross-compilation to aarch64: <pre><code>sudo apt-get install gcc-aarch64-linux-gnu\nrustup target add aarch64-unknown-linux-gnu\nmaturin build --release --target aarch64-unknown-linux-gnu\n</code></pre></p>"},{"location":"development/building/#macos","title":"macOS","text":"<p>Build for both architectures: <pre><code># ARM (native on M1/M2/M3)\nmaturin develop --release\n\n# Intel (cross-compile on ARM)\nrustup target add x86_64-apple-darwin\nmaturin build --release --target x86_64-apple-darwin\n</code></pre></p>"},{"location":"development/building/#windows","title":"Windows","text":"<p>Requires Visual Studio with C++ build tools: <pre><code># Install Rust from https://rustup.rs/\n\n# Build\nmaturin build --release\n</code></pre></p>"},{"location":"development/building/#benchmarks","title":"Benchmarks","text":"<pre><code># Python benchmarks\npython benchmarks/benchmark.py\n\n# Update performance docs\npython benchmarks/update_docs.py\n</code></pre>"},{"location":"development/building/#troubleshooting","title":"Troubleshooting","text":"<p>maturin not found: <pre><code>pip install --user maturin\n# Add ~/.local/bin to PATH\n</code></pre></p> <p>Rust compiler errors: <pre><code>rustup update\ncargo clean\nmaturin develop --release\n</code></pre></p> <p>Test failures: <pre><code># Clean build\ncargo clean\nrm -rf target/\nmaturin develop --release\npytest tests/python/ -v\n</code></pre></p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Contributions to jsonatapy are welcome!</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally</li> <li>Set up development environment</li> </ol> <pre><code>git clone https://github.com/txjmb/jsonata-core.git\ncd jsonatapy\ngit submodule update --init --recursive\n\n# Install Rust\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Install dependencies\npip install maturin pytest pytest-xdist\n\n# Build and test\nmaturin develop --release\npytest tests/python/ -v\n</code></pre>"},{"location":"development/contributing/#development-process","title":"Development Process","text":""},{"location":"development/contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/contributing/#2-make-changes","title":"2. Make Changes","text":"<ul> <li>Follow Rust and Python best practices</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> <li>Run tests and linters</li> </ul>"},{"location":"development/contributing/#3-test-your-changes","title":"3. Test Your Changes","text":"<pre><code># Format code\ncargo fmt\n\n# Lint\ncargo clippy\n\n# Run Rust tests\ncargo test\n\n# Build extension\nmaturin develop --release\n\n# Run Python tests\npytest tests/python/ -v\n</code></pre>"},{"location":"development/contributing/#4-commit","title":"4. Commit","text":"<pre><code>git add .\ngit commit -m \"Brief description of changes\"\n</code></pre> <p>Use conventional commit messages: - <code>feat:</code> New feature - <code>fix:</code> Bug fix - <code>docs:</code> Documentation - <code>test:</code> Tests - <code>refactor:</code> Code refactoring - <code>chore:</code> Maintenance</p>"},{"location":"development/contributing/#5-push-and-create-pull-request","title":"5. Push and Create Pull Request","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then create a pull request on GitHub.</p>"},{"location":"development/contributing/#code-guidelines","title":"Code Guidelines","text":""},{"location":"development/contributing/#rust-code","title":"Rust Code","text":"<ul> <li>Follow Rust 2021 edition standards</li> <li>Run <code>cargo fmt</code> before committing</li> <li>Pass <code>cargo clippy</code> with no warnings</li> <li>Add rustdoc comments for public APIs</li> <li>Use meaningful variable names</li> </ul>"},{"location":"development/contributing/#python-code","title":"Python Code","text":"<ul> <li>Follow PEP 8</li> <li>Add type hints where applicable</li> <li>Include docstrings for public functions</li> <li>Write clear, descriptive tests</li> </ul>"},{"location":"development/contributing/#testing","title":"Testing","text":"<ul> <li>All new features must include tests</li> <li>Tests should be clear and focused</li> <li>Use descriptive test names</li> <li>Aim for high test coverage</li> </ul>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>Update relevant documentation for changes</li> <li>Add examples for new features</li> <li>Keep documentation concise and clear</li> <li>No unnecessary emojis or commentary</li> </ul>"},{"location":"development/contributing/#architecture","title":"Architecture","text":"<p>jsonatapy mirrors the JavaScript reference implementation structure for easier synchronization:</p> <ul> <li><code>src/parser.rs</code> - Expression parser</li> <li><code>src/evaluator.rs</code> - Expression evaluator</li> <li><code>src/functions.rs</code> - Built-in functions</li> <li><code>src/datetime.rs</code> - Date/time functions</li> <li><code>src/signature.rs</code> - Function signature validation</li> </ul> <p>See CLAUDE.MD for detailed architecture notes.</p>"},{"location":"development/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting bugs: - Include minimal reproduction case - Specify Python version and platform - Include error messages and stack traces - Check if issue already exists</p>"},{"location":"development/contributing/#questions","title":"Questions?","text":"<ul> <li>Check existing documentation</li> <li>Review CLAUDE.MD for design guidelines</li> <li>Open an issue for discussion</li> </ul>"},{"location":"development/parser/","title":"JSONata Parser Implementation","text":"<p>Complete implementation of the JSONata parser in Rust.</p>"},{"location":"development/parser/#file-location","title":"File Location","text":"<p><code>src/parser.rs</code> (1,242 lines)</p>"},{"location":"development/parser/#quick-start","title":"Quick Start","text":"<pre><code>use jsonatapy::parser::parse;\n\n// Parse an expression\nlet ast = parse(\"orders[price &gt; 100].product\")?;\n</code></pre>"},{"location":"development/parser/#features","title":"Features","text":""},{"location":"development/parser/#lexer","title":"Lexer","text":"<p>The lexer converts JSONata expressions into tokens:</p> <pre><code>let mut lexer = Lexer::new(\"1 + 2\".to_string());\nlet token1 = lexer.next_token()?; // Token::Number(1.0)\nlet token2 = lexer.next_token()?; // Token::Plus\nlet token3 = lexer.next_token()?; // Token::Number(2.0)\n</code></pre> <p>Supported tokens: - Literals: numbers, strings, booleans, null - Identifiers: <code>foo</code>, <code>bar_baz</code>, <code>`with spaces`</code> - Variables: <code>$var</code> - Operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>and</code>, <code>or</code>, <code>in</code>, <code>&amp;</code>, <code>.</code>, <code>..</code>, <code>:=</code> - Delimiters: <code>()</code>, <code>[]</code>, <code>{}</code>, <code>,</code>, <code>;</code>, <code>:</code>, <code>?</code> - Comments: <code>/* ... */</code></p>"},{"location":"development/parser/#parser","title":"Parser","text":"<p>The parser uses Pratt parsing (Top-Down Operator Precedence) to build an AST.</p> <p>Operator precedence: 1. Function call <code>()</code>, array access <code>[]</code> - 80 2. Dot operator <code>.</code> - 75 3. Multiplication <code>*</code>, division <code>/</code>, modulo <code>%</code> - 60 4. Addition <code>+</code>, subtraction <code>-</code>, concatenation <code>&amp;</code> - 50 5. Comparison <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, etc. - 40 6. Logical AND <code>and</code> - 30 7. Logical OR <code>or</code> - 25 8. Range <code>..</code>, ternary <code>?</code> - 20 9. Assignment <code>:=</code> - 10 (right-associative)</p>"},{"location":"development/parser/#testing","title":"Testing","text":"<p>Run the comprehensive test suite:</p> <pre><code>cargo test --lib parser\n</code></pre> <p>The test suite includes 35+ tests covering all features.</p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>Comprehensive guide to testing in jsonatapy.</p>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>jsonatapy has three layers of testing:</p> <pre><code>tests/\n\u251c\u2500\u2500 python/                      # Python integration tests\n\u2502   \u251c\u2500\u2500 test_reference_suite.py  # Reference suite runner (1258 tests)\n\u2502   \u251c\u2500\u2500 test_basic.py            # Basic functionality\n\u2502   \u251c\u2500\u2500 test_functions.py        # Built-in functions\n\u2502   \u251c\u2500\u2500 test_lambda.py           # Lambda functions\n\u2502   \u251c\u2500\u2500 test_performance.py      # Performance benchmarks\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 jsonata-js/                  # Reference test suite (git submodule)\n\u2502   \u2514\u2500\u2500 test/test-suite/         # Official JSONata test cases\n\u2514\u2500\u2500 (Rust unit tests in src/*.rs with #[cfg(test)])\n</code></pre>"},{"location":"development/testing/#test-layers","title":"Test Layers","text":"<ol> <li>Rust Unit Tests (31 tests)</li> <li>Low-level component testing</li> <li>Pure Rust, no Python</li> <li>Fast execution</li> <li> <p>Located in <code>src/*.rs</code> modules</p> </li> <li> <p>Python Integration Tests (~50 tests)</p> </li> <li>End-to-end Python API testing</li> <li>Python bindings verification</li> <li>Error handling validation</li> <li> <p>Located in <code>tests/python/</code></p> </li> <li> <p>Reference Test Suite (1258 tests)</p> </li> <li>Official JSONata compatibility tests</li> <li>Comprehensive language feature coverage</li> <li>Ensures 100% compatibility with jsonata-js</li> <li>Imported from jsonata-js repository</li> </ol>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#all-tests","title":"All Tests","text":"<pre><code># Rust unit tests (fast)\ncargo test\n\n# Python integration tests\npytest tests/python/ -v\n\n# Reference test suite (comprehensive)\nuv run pytest tests/python/test_reference_suite.py\n\n# Run everything\ncargo test &amp;&amp; pytest tests/python/ -v\n</code></pre>"},{"location":"development/testing/#specific-tests","title":"Specific Tests","text":"<pre><code># Single Rust test\ncargo test test_evaluate_path\n\n# Single Python test file\npytest tests/python/test_functions.py -v\n\n# Single Python test\npytest tests/python/test_functions.py::test_sum_function -v\n\n# Tests matching pattern\npytest tests/python/ -k \"lambda\" -v\n</code></pre>"},{"location":"development/testing/#test-output","title":"Test Output","text":"<pre><code># Show print statements\ncargo test -- --nocapture\npytest tests/python/ -v -s\n\n# Show detailed output\ncargo test -- --show-output\npytest tests/python/ -vv\n\n# Stop on first failure\npytest tests/python/ -x\n</code></pre>"},{"location":"development/testing/#performance","title":"Performance","text":"<pre><code># Run tests serially (for timing)\ncargo test -- --test-threads=1\n\n# Run Python tests in parallel\npytest tests/python/ -n auto\n\n# Skip slow tests\npytest tests/python/ -m \"not slow\"\n</code></pre>"},{"location":"development/testing/#rust-unit-tests","title":"Rust Unit Tests","text":""},{"location":"development/testing/#location","title":"Location","text":"<p>Rust unit tests are in the same file as the code, using <code>#[cfg(test)]</code>:</p> <pre><code>// src/functions.rs\n\npub fn sum(values: &amp;[JValue]) -&gt; Result&lt;JValue, EvalError&gt; {\n    // Implementation\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sum_values() {\n        let values = vec![\n            JValue::Number(1.0),\n            JValue::Number(2.0),\n            JValue::Number(3.0),\n        ];\n        let result = sum(&amp;values).unwrap();\n        assert_eq!(result, JValue::Number(6.0));\n    }\n}\n</code></pre>"},{"location":"development/testing/#running-rust-tests","title":"Running Rust Tests","text":"<pre><code># All Rust tests\ncargo test\n\n# Specific module\ncargo test evaluator::tests\n\n# Specific test\ncargo test test_evaluate_path\n\n# With output\ncargo test -- --nocapture\n\n# Release mode (faster but slower to compile)\ncargo test --release\n</code></pre>"},{"location":"development/testing/#rust-test-examples","title":"Rust Test Examples","text":"<p>Test successful operation: <pre><code>#[test]\nfn test_filter_array() {\n    let arr = JValue::array(vec![\n        JValue::Number(1.0),\n        JValue::Number(2.0),\n        JValue::Number(3.0),\n    ]);\n    let predicate = |v: &amp;JValue| matches!(v, JValue::Number(n) if *n &gt; 1.0);\n    let result = filter_array(&amp;arr, predicate).unwrap();\n    assert_eq!(result.len(), 2);\n}\n</code></pre></p> <p>Test error conditions: <pre><code>#[test]\nfn test_sum_invalid_type() {\n    let values = vec![JValue::String(Rc::from(\"not a number\"))];\n    let result = sum(&amp;values);\n    assert!(result.is_err());\n    assert!(matches!(result.unwrap_err(), EvalError::TypeError(_)));\n}\n</code></pre></p> <p>Test edge cases: <pre><code>#[test]\nfn test_sum_empty_array() {\n    let values = vec![];\n    let result = sum(&amp;values).unwrap();\n    assert_eq!(result, JValue::Undefined);\n}\n\n#[test]\nfn test_sum_with_null() {\n    let values = vec![JValue::Number(1.0), JValue::Null, JValue::Number(2.0)];\n    let result = sum(&amp;values).unwrap();\n    assert_eq!(result, JValue::Number(3.0));\n}\n</code></pre></p>"},{"location":"development/testing/#python-integration-tests","title":"Python Integration Tests","text":""},{"location":"development/testing/#location_1","title":"Location","text":"<p>Python tests are in <code>tests/python/</code>:</p> <pre><code># tests/python/test_functions.py\n\nimport jsonatapy\nimport pytest\n\ndef test_sum_function():\n    \"\"\"Test $sum function with array of numbers.\"\"\"\n    result = jsonatapy.evaluate(\"$sum([1, 2, 3])\", {})\n    assert result == 6\n\ndef test_sum_invalid_input():\n    \"\"\"Test $sum with invalid input raises error.\"\"\"\n    with pytest.raises(ValueError, match=\"must be an array\"):\n        jsonatapy.evaluate(\"$sum('not an array')\", {})\n</code></pre>"},{"location":"development/testing/#running-python-tests","title":"Running Python Tests","text":"<pre><code># All Python tests\npytest tests/python/ -v\n\n# Specific file\npytest tests/python/test_functions.py -v\n\n# Specific test\npytest tests/python/test_functions.py::test_sum_function -v\n\n# Pattern matching\npytest tests/python/ -k \"sum or count\" -v\n\n# Show print statements\npytest tests/python/ -v -s\n</code></pre>"},{"location":"development/testing/#python-test-examples","title":"Python Test Examples","text":"<p>Basic functionality: <pre><code>def test_path_expression():\n    \"\"\"Test simple path expression.\"\"\"\n    data = {\"name\": \"Alice\", \"age\": 30}\n    result = jsonatapy.evaluate(\"name\", data)\n    assert result == \"Alice\"\n</code></pre></p> <p>Error handling: <pre><code>def test_parse_error():\n    \"\"\"Test invalid expression raises ValueError.\"\"\"\n    with pytest.raises(ValueError, match=\"Unexpected token\"):\n        jsonatapy.compile(\"invalid [[\")\n</code></pre></p> <p>Parameterized tests: <pre><code>@pytest.mark.parametrize(\"expression,data,expected\", [\n    (\"$sum([1, 2, 3])\", {}, 6),\n    (\"$sum([1.5, 2.5])\", {}, 4.0),\n    (\"$sum([10])\", {}, 10),\n])\ndef test_sum_cases(expression, data, expected):\n    \"\"\"Test $sum with various inputs.\"\"\"\n    result = jsonatapy.evaluate(expression, data)\n    assert result == expected\n</code></pre></p> <p>Fixtures: <pre><code>@pytest.fixture\ndef sample_data():\n    \"\"\"Sample data for testing.\"\"\"\n    return {\n        \"orders\": [\n            {\"product\": \"Widget\", \"price\": 10, \"quantity\": 2},\n            {\"product\": \"Gadget\", \"price\": 25, \"quantity\": 1},\n        ]\n    }\n\ndef test_with_fixture(sample_data):\n    \"\"\"Test using fixture data.\"\"\"\n    result = jsonatapy.evaluate(\"$sum(orders.(price * quantity))\", sample_data)\n    assert result == 45\n</code></pre></p>"},{"location":"development/testing/#reference-test-suite","title":"Reference Test Suite","text":""},{"location":"development/testing/#overview","title":"Overview","text":"<p>The reference test suite contains 1258 tests from the official jsonata-js repository. These tests ensure 100% compatibility with the JSONata specification.</p>"},{"location":"development/testing/#location_2","title":"Location","text":"<p>Tests are in the <code>tests/jsonata-js</code> git submodule:</p> <pre><code># Initialize submodule\ngit submodule update --init --recursive\n\n# Update submodule\ngit submodule update --remote tests/jsonata-js\n</code></pre>"},{"location":"development/testing/#running-reference-tests","title":"Running Reference Tests","text":"<pre><code># All reference tests (1258 tests)\nuv run pytest tests/python/test_reference_suite.py\n\n# Verbose output\nuv run pytest tests/python/test_reference_suite.py -v\n\n# Stop on first failure\nuv run pytest tests/python/test_reference_suite.py -x\n\n# Show which tests pass/fail\nuv run pytest tests/python/test_reference_suite.py -v --tb=short\n</code></pre>"},{"location":"development/testing/#test-format","title":"Test Format","text":"<p>Reference tests are JSON files:</p> <pre><code>{\n  \"description\": \"Test description\",\n  \"expression\": \"items[price &gt; 100]\",\n  \"data\": {\n    \"items\": [\n      {\"name\": \"Widget\", \"price\": 150},\n      {\"name\": \"Gadget\", \"price\": 50}\n    ]\n  },\n  \"result\": [\n    {\"name\": \"Widget\", \"price\": 150}\n  ]\n}\n</code></pre>"},{"location":"development/testing/#test-categories","title":"Test Categories","text":"<p>Reference tests cover:</p> <ul> <li>Path expressions</li> <li>Predicates and filtering</li> <li>Array operations</li> <li>Object construction</li> <li>Built-in functions (40+)</li> <li>Lambda functions</li> <li>Higher-order functions</li> <li>String operations</li> <li>Numeric operations</li> <li>Boolean logic</li> <li>Aggregations</li> <li>Edge cases</li> </ul>"},{"location":"development/testing/#adding-new-tests","title":"Adding New Tests","text":""},{"location":"development/testing/#when-to-add-tests","title":"When to Add Tests","text":"<ul> <li>New Features: All new features require tests</li> <li>Bug Fixes: Regression tests for fixed bugs</li> <li>Edge Cases: Unusual inputs or corner cases</li> <li>Performance: Benchmarks for optimized code</li> </ul>"},{"location":"development/testing/#adding-rust-unit-tests","title":"Adding Rust Unit Tests","text":"<pre><code>// src/functions.rs\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_function() {\n        // Arrange\n        let input = JValue::array(vec![JValue::Number(1.0)]);\n\n        // Act\n        let result = new_function(&amp;input).unwrap();\n\n        // Assert\n        assert_eq!(result, JValue::Number(1.0));\n    }\n\n    #[test]\n    fn test_new_function_error() {\n        let input = JValue::String(Rc::from(\"invalid\"));\n        let result = new_function(&amp;input);\n        assert!(result.is_err());\n    }\n}\n</code></pre>"},{"location":"development/testing/#adding-python-tests","title":"Adding Python Tests","text":"<pre><code># tests/python/test_new_feature.py\n\nimport jsonatapy\nimport pytest\n\nclass TestNewFeature:\n    \"\"\"Tests for new feature.\"\"\"\n\n    def test_basic_usage(self):\n        \"\"\"Test basic usage of new feature.\"\"\"\n        result = jsonatapy.evaluate(\"$newFunc([1, 2, 3])\", {})\n        assert result == expected_value\n\n    def test_edge_case(self):\n        \"\"\"Test edge case handling.\"\"\"\n        result = jsonatapy.evaluate(\"$newFunc([])\", {})\n        assert result is None\n\n    def test_error_handling(self):\n        \"\"\"Test error is raised for invalid input.\"\"\"\n        with pytest.raises(ValueError, match=\"expected\"):\n            jsonatapy.evaluate(\"$newFunc('invalid')\", {})\n\n    @pytest.mark.parametrize(\"input,expected\", [\n        ([1, 2, 3], 6),\n        ([10], 10),\n        ([], None),\n    ])\n    def test_multiple_cases(self, input, expected):\n        \"\"\"Test multiple input cases.\"\"\"\n        result = jsonatapy.evaluate(f\"$newFunc({input})\", {})\n        assert result == expected\n</code></pre>"},{"location":"development/testing/#test-naming","title":"Test Naming","text":"<p>Use descriptive names:</p> <p>Good: <pre><code>test_sum_empty_array()\ntest_sum_with_null_values()\ntest_sum_invalid_type_raises_error()\n</code></pre></p> <p>Bad: <pre><code>test_1()\ntest_sum()\ntest_error()\n</code></pre></p>"},{"location":"development/testing/#coverage-requirements","title":"Coverage Requirements","text":""},{"location":"development/testing/#target-coverage","title":"Target Coverage","text":"<p>Required: 100% coverage (matching upstream jsonata-js)</p>"},{"location":"development/testing/#measuring-coverage","title":"Measuring Coverage","text":"<p>Rust: <pre><code># Install tarpaulin\ncargo install cargo-tarpaulin\n\n# Generate coverage report\ncargo tarpaulin --out Html\n# Opens in browser: target/tarpaulin-report.html\n</code></pre></p> <p>Python: <pre><code># Run tests with coverage\npytest tests/python/ --cov=jsonatapy --cov-report=html\n\n# View report\nopen htmlcov/index.html\n</code></pre></p>"},{"location":"development/testing/#coverage-reports","title":"Coverage Reports","text":"<pre><code># Combined coverage report\ncargo tarpaulin --out Html\npytest tests/python/ --cov=jsonatapy --cov-report=html\n\n# CI coverage\ncargo tarpaulin --out Xml\npytest tests/python/ --cov=jsonatapy --cov-report=xml\n</code></pre>"},{"location":"development/testing/#test-best-practices","title":"Test Best Practices","text":""},{"location":"development/testing/#1-test-one-thing-at-a-time","title":"1. Test One Thing at a Time","text":"<pre><code># Good - focused test\ndef test_sum_returns_total():\n    result = jsonatapy.evaluate(\"$sum([1, 2, 3])\", {})\n    assert result == 6\n\n# Bad - tests multiple things\ndef test_sum_and_count():\n    sum_result = jsonatapy.evaluate(\"$sum([1, 2, 3])\", {})\n    count_result = jsonatapy.evaluate(\"$count([1, 2, 3])\", {})\n    assert sum_result == 6\n    assert count_result == 3\n</code></pre>"},{"location":"development/testing/#2-use-descriptive-assertions","title":"2. Use Descriptive Assertions","text":"<pre><code># Good - clear assertion message\nassert result == expected, f\"Expected {expected}, got {result}\"\n\n# Good - pytest provides good messages\nassert result == expected\n\n# Bad - no context on failure\nassert result\n</code></pre>"},{"location":"development/testing/#3-test-edge-cases","title":"3. Test Edge Cases","text":"<pre><code>def test_sum_function():\n    # Normal case\n    assert jsonatapy.evaluate(\"$sum([1, 2, 3])\", {}) == 6\n\n    # Edge cases\n    assert jsonatapy.evaluate(\"$sum([])\", {}) is None\n    assert jsonatapy.evaluate(\"$sum([1])\", {}) == 1\n    assert jsonatapy.evaluate(\"$sum([1, null, 2])\", {}) == 3\n</code></pre>"},{"location":"development/testing/#4-test-error-conditions","title":"4. Test Error Conditions","text":"<pre><code>def test_error_handling():\n    # Test specific error message\n    with pytest.raises(ValueError, match=\"must be an array\"):\n        jsonatapy.evaluate(\"$sum('not an array')\", {})\n\n    # Test error type\n    with pytest.raises(ValueError):\n        jsonatapy.compile(\"invalid [[\")\n</code></pre>"},{"location":"development/testing/#5-use-fixtures-for-shared-data","title":"5. Use Fixtures for Shared Data","text":"<pre><code>@pytest.fixture\ndef sample_orders():\n    return {\n        \"orders\": [\n            {\"product\": \"A\", \"price\": 10},\n            {\"product\": \"B\", \"price\": 20},\n        ]\n    }\n\ndef test_with_fixture(sample_orders):\n    result = jsonatapy.evaluate(\"$sum(orders.price)\", sample_orders)\n    assert result == 30\n</code></pre>"},{"location":"development/testing/#6-group-related-tests","title":"6. Group Related Tests","text":"<pre><code>class TestSumFunction:\n    \"\"\"Tests for $sum function.\"\"\"\n\n    def test_sum_numbers(self):\n        pass\n\n    def test_sum_empty_array(self):\n        pass\n\n    def test_sum_with_nulls(self):\n        pass\n</code></pre>"},{"location":"development/testing/#7-document-test-purpose","title":"7. Document Test Purpose","text":"<pre><code>def test_sum_ignores_null_values():\n    \"\"\"\n    Test that $sum correctly ignores null values in array.\n\n    According to JSONata spec, null values should be skipped\n    during summation.\n    \"\"\"\n    result = jsonatapy.evaluate(\"$sum([1, null, 2, null, 3])\", {})\n    assert result == 6\n</code></pre>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"development/testing/#ci-pipeline","title":"CI Pipeline","text":"<p>All tests run on CI for: - Platforms: Linux, macOS, Windows - Python versions: 3.10, 3.11, 3.12, 3.13 - Architectures: x86_64, aarch64</p>"},{"location":"development/testing/#ci-commands","title":"CI Commands","text":"<pre><code># .github/workflows/test.yml\n- name: Run Rust tests\n  run: cargo test\n\n- name: Run Python tests\n  run: |\n    maturin develop --release\n    pytest tests/python/ -v\n\n- name: Run reference suite\n  run: uv run pytest tests/python/test_reference_suite.py\n</code></pre>"},{"location":"development/testing/#test-maintenance","title":"Test Maintenance","text":""},{"location":"development/testing/#regular-tasks","title":"Regular Tasks","text":"<ol> <li> <p>Keep reference suite updated: <pre><code>git submodule update --remote tests/jsonata-js\n</code></pre></p> </li> <li> <p>Review failing tests: <pre><code>pytest tests/python/ --lf  # Run last failed\n</code></pre></p> </li> <li> <p>Update test data:</p> </li> <li>Review test coverage reports</li> <li>Add tests for uncovered code</li> <li>Remove obsolete tests</li> </ol>"},{"location":"development/testing/#test-quality-checklist","title":"Test Quality Checklist","text":"<ul> <li> Tests pass locally</li> <li> Tests are deterministic (no random failures)</li> <li> Tests are fast (&lt; 1s each for unit tests)</li> <li> Tests are independent (no shared state)</li> <li> Tests have clear names</li> <li> Tests have docstrings</li> <li> Edge cases covered</li> <li> Error cases covered</li> <li> Coverage maintained at 100%</li> </ul>"},{"location":"development/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about contributing</li> <li>Review building guide</li> <li>Understand architecture</li> <li>Check API reference</li> </ul>"}]}